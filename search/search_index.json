{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BubbleBox - 21st century educational toys for jedi-minded scientists BubbleBox is a Python-module for doing molecular simulations directly in Jupyter Notebooks. It's main purpose is to allow students to build intuition and understanding of concepts in thermodynamics and chemistry by playing around with systems that exhibits many of the familiar phenomenas we observe in nature such as time evolution, equilibrium, temperature, pressure, phases- and phase changes, entropy, diffusion, mixing and much more. By closely relating theoretical concepts to experimental observations, BubbleBox opens the door for in-depth learning and exploration of our theoretical framework for the physical world in an engaging and interactive way. BubbleBox is being developed by Audun Skau Hansen (a.s.hansen@kjemi.uio.no) at the Department of Chemistry, Hylleraas Centre for Quantum Molecular Sciences, University of Oslo. Dependencies Numpy Matplotlib Numba Installation Install the BubbleBox-module using pip install bubblebox from your terminal.","title":"Home"},{"location":"#bubblebox-21st-century-educational-toys-for-jedi-minded-scientists","text":"BubbleBox is a Python-module for doing molecular simulations directly in Jupyter Notebooks. It's main purpose is to allow students to build intuition and understanding of concepts in thermodynamics and chemistry by playing around with systems that exhibits many of the familiar phenomenas we observe in nature such as time evolution, equilibrium, temperature, pressure, phases- and phase changes, entropy, diffusion, mixing and much more. By closely relating theoretical concepts to experimental observations, BubbleBox opens the door for in-depth learning and exploration of our theoretical framework for the physical world in an engaging and interactive way. BubbleBox is being developed by Audun Skau Hansen (a.s.hansen@kjemi.uio.no) at the Department of Chemistry, Hylleraas Centre for Quantum Molecular Sciences, University of Oslo.","title":"BubbleBox -  21st century educational toys for jedi-minded scientists"},{"location":"#dependencies","text":"Numpy Matplotlib Numba","title":"Dependencies"},{"location":"#installation","text":"Install the BubbleBox-module using pip install bubblebox from your terminal.","title":"Installation"},{"location":"binding_models-reference/","text":"Binding models module bindingbox __init__ ( self , number_of_polymers , n_polymer_sites , number_of_ligands , number_of_solvent_molecules , interaction_matrix , initialize_in_ground_state = False , kT = 0.4 ) special Initialize model explain how to initialize energy Source code in bubblebox/binding_models.py def __init__ ( self , number_of_polymers , n_polymer_sites , number_of_ligands , number_of_solvent_molecules , interaction_matrix , initialize_in_ground_state = False , kT = 0.4 ): \"\"\" Initialize model - explain how to initialize energy \"\"\" self . nl = number_of_ligands self . np = number_of_polymers # number of polymers self . lp = n_polymer_sites # number of binding sites at each polymer self . interaction_matrix = interaction_matrix # interaction matrix for each polymer self . lattice_size = number_of_ligands + number_of_polymers * n_polymer_sites + number_of_solvent_molecules self . polymer_partition = self . np * self . lp self . particle_partition = self . polymer_partition + number_of_ligands # Temperature self . kT = kT self . lattice = np . zeros ( self . polymer_partition + self . nl + 1 , dtype = bool ) self . lattice [ self . polymer_partition :] = True # free ligands self . lattice [ - 1 ] = False # a spot reserved for the solvent if initialize_in_ground_state : self . lattice [:] = False self . lattice [: self . nl ] = True n_bound_ligands = np . sum ( self . lattice [: self . polymer_partition ]) self . lattice [ self . polymer_partition : self . particle_partition - n_bound_ligands ] = True self . lattice [ self . particle_partition - n_bound_ligands :] = False self . energy = self . compute_energy () advance ( self ) Do one Monte Carlo step Source code in bubblebox/binding_models.py def advance ( self ): \"\"\" Do one Monte Carlo step \"\"\" # pick to random different sites #P = np.random.choice(self.lattice_size, 2, replace = False) P = np . random . randint ( 0 , self . lattice_size , 2 ) P [ P > self . lattice . shape [ 0 ] - 1 ] = self . lattice . shape [ 0 ] - 1 if P [ 0 ] != P [ 1 ]: #print(P) # all #print(P, self.lattice) # check if sites are occupied P0_occupied = self . lattice [ P [ 0 ]] P1_occupied = self . lattice [ P [ 1 ]] if P0_occupied != P1_occupied : # if swap involves state change, perform swap # set occupation following change self . lattice [ P [ 0 ]] = P1_occupied self . lattice [ P [ 1 ]] = P0_occupied # compute new energy, and energy difference new_energy = self . compute_energy () energy_change = new_energy - self . energy # Monte Carlo step if np . exp ( - energy_change / self . kT ) > np . random . uniform ( 0 , 1 ): # accept move # update energy self . energy = new_energy * 1 # resolve number of bound ligands n_bound_ligands = np . sum ( self . lattice [: self . polymer_partition ]) self . lattice [ self . polymer_partition : self . particle_partition - n_bound_ligands ] = True self . lattice [ self . particle_partition - n_bound_ligands :] = False else : # reject step and revert changes self . lattice [ P [ 0 ]] = P0_occupied self . lattice [ P [ 1 ]] = P1_occupied compute_average_populations ( self ) Source code in bubblebox/binding_models.py def compute_average_populations ( self ): \"\"\" \"\"\" lattice = self . lattice [: self . polymer_partition ] . reshape ( self . np , self . lp ) occupancy = np . sum ( lattice , axis = 1 ) oc = np . bincount ( occupancy ) / self . np occu = np . zeros ( 3 ) occu [: len ( oc )] = oc return occu compute_energy ( self ) Compute energy of lattice Source code in bubblebox/binding_models.py def compute_energy ( self ): \"\"\" Compute energy of lattice \"\"\" e = 0 lattice = self . lattice [: self . polymer_partition ] . reshape ( self . np , self . lp ) for i in range ( self . interaction_matrix . shape [ 0 ]): ei = self . interaction_matrix [ i ] ni = ei . shape [ 0 ] #print(self.interaction_matrix[i][None, :-i+1]) #print(np.sum((lattice*np.roll(lattice, i, axis = 0))[:-i+1])) #print(self.interaction_matrix[i][None,:-i]) e += np . sum (( lattice * np . roll ( lattice , i , axis = 1 ))[:, i : ni ] * ei [ None , i : ni ]) return e compute_energy_ ( self ) Compute energy of lattice Source code in bubblebox/binding_models.py def compute_energy_ ( self ): \"\"\" Compute energy of lattice \"\"\" e = 0 lattice = self . lattice [: self . polymer_partition ] . reshape ( self . np , self . lp ) for i in range ( self . interaction_matrix . shape [ 0 ]): e += np . sum ( lattice * np . roll ( lattice , i , axis = 0 )) * self . interaction_matrix [ i ] return e compute_occupation ( self ) Compute mean nuumber of occupied sites per polymer Source code in bubblebox/binding_models.py def compute_occupation ( self ): \"\"\" Compute mean nuumber of occupied sites per polymer \"\"\" lattice = self . lattice [: self . polymer_partition ] . reshape ( self . np , self . lp ) return np . mean ( np . sum ( lattice , axis = 1 )) compute_sitewise_occupation ( self ) Compute mean nuumber of occupied sites per polymer Source code in bubblebox/binding_models.py def compute_sitewise_occupation ( self ): \"\"\" Compute mean nuumber of occupied sites per polymer \"\"\" lattice = self . lattice [: self . polymer_partition ] . reshape ( self . np , self . lp ) return np . mean ( lattice , axis = 0 ) evolve ( self , Nt ) Perform Nt Monte Carlo steps Source code in bubblebox/binding_models.py def evolve ( self , Nt ): \"\"\" Perform Nt Monte Carlo steps \"\"\" for i in range ( Nt ): self . advance () fit_langmuir_model ( concentration , occupancy , A = 2 ) fit to a Langmuir adsorption model \begin{equation} heta(X) = A * rac{KX}{1 + KX}, \\end{equation} where X is consentration and K is the equilibrium constant function returns K Source code in bubblebox/binding_models.py def fit_langmuir_model ( concentration , occupancy , A = 2 ): \"\"\" fit to a Langmuir adsorption model \\begin{equation} \\theta(X) = A * \\frac{KX}{1 + KX}, \\end{equation} where X is consentration and K is the equilibrium constant function returns K \"\"\" R = lambda k , c = concentration , o = occupancy , A = A : ( A * k * c / ( 1 + k * c ) - o ) ** 2 #residual function #extract and return K return least_squares ( R , np . array ([ 1 ]) ) . x [ 0 ]","title":"binding_models"},{"location":"binding_models-reference/#binding-models-module","text":"","title":"Binding models module"},{"location":"binding_models-reference/#bubblebox.binding_models.bindingbox","text":"","title":"bindingbox"},{"location":"binding_models-reference/#bubblebox.binding_models.bindingbox.__init__","text":"Initialize model explain how to initialize energy Source code in bubblebox/binding_models.py def __init__ ( self , number_of_polymers , n_polymer_sites , number_of_ligands , number_of_solvent_molecules , interaction_matrix , initialize_in_ground_state = False , kT = 0.4 ): \"\"\" Initialize model - explain how to initialize energy \"\"\" self . nl = number_of_ligands self . np = number_of_polymers # number of polymers self . lp = n_polymer_sites # number of binding sites at each polymer self . interaction_matrix = interaction_matrix # interaction matrix for each polymer self . lattice_size = number_of_ligands + number_of_polymers * n_polymer_sites + number_of_solvent_molecules self . polymer_partition = self . np * self . lp self . particle_partition = self . polymer_partition + number_of_ligands # Temperature self . kT = kT self . lattice = np . zeros ( self . polymer_partition + self . nl + 1 , dtype = bool ) self . lattice [ self . polymer_partition :] = True # free ligands self . lattice [ - 1 ] = False # a spot reserved for the solvent if initialize_in_ground_state : self . lattice [:] = False self . lattice [: self . nl ] = True n_bound_ligands = np . sum ( self . lattice [: self . polymer_partition ]) self . lattice [ self . polymer_partition : self . particle_partition - n_bound_ligands ] = True self . lattice [ self . particle_partition - n_bound_ligands :] = False self . energy = self . compute_energy ()","title":"__init__()"},{"location":"binding_models-reference/#bubblebox.binding_models.bindingbox.advance","text":"Do one Monte Carlo step Source code in bubblebox/binding_models.py def advance ( self ): \"\"\" Do one Monte Carlo step \"\"\" # pick to random different sites #P = np.random.choice(self.lattice_size, 2, replace = False) P = np . random . randint ( 0 , self . lattice_size , 2 ) P [ P > self . lattice . shape [ 0 ] - 1 ] = self . lattice . shape [ 0 ] - 1 if P [ 0 ] != P [ 1 ]: #print(P) # all #print(P, self.lattice) # check if sites are occupied P0_occupied = self . lattice [ P [ 0 ]] P1_occupied = self . lattice [ P [ 1 ]] if P0_occupied != P1_occupied : # if swap involves state change, perform swap # set occupation following change self . lattice [ P [ 0 ]] = P1_occupied self . lattice [ P [ 1 ]] = P0_occupied # compute new energy, and energy difference new_energy = self . compute_energy () energy_change = new_energy - self . energy # Monte Carlo step if np . exp ( - energy_change / self . kT ) > np . random . uniform ( 0 , 1 ): # accept move # update energy self . energy = new_energy * 1 # resolve number of bound ligands n_bound_ligands = np . sum ( self . lattice [: self . polymer_partition ]) self . lattice [ self . polymer_partition : self . particle_partition - n_bound_ligands ] = True self . lattice [ self . particle_partition - n_bound_ligands :] = False else : # reject step and revert changes self . lattice [ P [ 0 ]] = P0_occupied self . lattice [ P [ 1 ]] = P1_occupied","title":"advance()"},{"location":"binding_models-reference/#bubblebox.binding_models.bindingbox.compute_average_populations","text":"Source code in bubblebox/binding_models.py def compute_average_populations ( self ): \"\"\" \"\"\" lattice = self . lattice [: self . polymer_partition ] . reshape ( self . np , self . lp ) occupancy = np . sum ( lattice , axis = 1 ) oc = np . bincount ( occupancy ) / self . np occu = np . zeros ( 3 ) occu [: len ( oc )] = oc return occu","title":"compute_average_populations()"},{"location":"binding_models-reference/#bubblebox.binding_models.bindingbox.compute_energy","text":"Compute energy of lattice Source code in bubblebox/binding_models.py def compute_energy ( self ): \"\"\" Compute energy of lattice \"\"\" e = 0 lattice = self . lattice [: self . polymer_partition ] . reshape ( self . np , self . lp ) for i in range ( self . interaction_matrix . shape [ 0 ]): ei = self . interaction_matrix [ i ] ni = ei . shape [ 0 ] #print(self.interaction_matrix[i][None, :-i+1]) #print(np.sum((lattice*np.roll(lattice, i, axis = 0))[:-i+1])) #print(self.interaction_matrix[i][None,:-i]) e += np . sum (( lattice * np . roll ( lattice , i , axis = 1 ))[:, i : ni ] * ei [ None , i : ni ]) return e","title":"compute_energy()"},{"location":"binding_models-reference/#bubblebox.binding_models.bindingbox.compute_energy_","text":"Compute energy of lattice Source code in bubblebox/binding_models.py def compute_energy_ ( self ): \"\"\" Compute energy of lattice \"\"\" e = 0 lattice = self . lattice [: self . polymer_partition ] . reshape ( self . np , self . lp ) for i in range ( self . interaction_matrix . shape [ 0 ]): e += np . sum ( lattice * np . roll ( lattice , i , axis = 0 )) * self . interaction_matrix [ i ] return e","title":"compute_energy_()"},{"location":"binding_models-reference/#bubblebox.binding_models.bindingbox.compute_occupation","text":"Compute mean nuumber of occupied sites per polymer Source code in bubblebox/binding_models.py def compute_occupation ( self ): \"\"\" Compute mean nuumber of occupied sites per polymer \"\"\" lattice = self . lattice [: self . polymer_partition ] . reshape ( self . np , self . lp ) return np . mean ( np . sum ( lattice , axis = 1 ))","title":"compute_occupation()"},{"location":"binding_models-reference/#bubblebox.binding_models.bindingbox.compute_sitewise_occupation","text":"Compute mean nuumber of occupied sites per polymer Source code in bubblebox/binding_models.py def compute_sitewise_occupation ( self ): \"\"\" Compute mean nuumber of occupied sites per polymer \"\"\" lattice = self . lattice [: self . polymer_partition ] . reshape ( self . np , self . lp ) return np . mean ( lattice , axis = 0 )","title":"compute_sitewise_occupation()"},{"location":"binding_models-reference/#bubblebox.binding_models.bindingbox.evolve","text":"Perform Nt Monte Carlo steps Source code in bubblebox/binding_models.py def evolve ( self , Nt ): \"\"\" Perform Nt Monte Carlo steps \"\"\" for i in range ( Nt ): self . advance ()","title":"evolve()"},{"location":"binding_models-reference/#bubblebox.binding_models.fit_langmuir_model","text":"fit to a Langmuir adsorption model \begin{equation} heta(X) = A * rac{KX}{1 + KX}, \\end{equation} where X is consentration and K is the equilibrium constant function returns K Source code in bubblebox/binding_models.py def fit_langmuir_model ( concentration , occupancy , A = 2 ): \"\"\" fit to a Langmuir adsorption model \\begin{equation} \\theta(X) = A * \\frac{KX}{1 + KX}, \\end{equation} where X is consentration and K is the equilibrium constant function returns K \"\"\" R = lambda k , c = concentration , o = occupancy , A = A : ( A * k * c / ( 1 + k * c ) - o ) ** 2 #residual function #extract and return K return least_squares ( R , np . array ([ 1 ]) ) . x [ 0 ]","title":"fit_langmuir_model()"},{"location":"bubblebox-reference/","text":"Bubblebox module","title":"bubblebox"},{"location":"bubblebox-reference/#bubblebox-module","text":"","title":"Bubblebox module"},{"location":"install/","text":"Out-of-the-box outside-of-the-box thinking BraketLab is a Python-module for doing quantum theory in Jupyter Notebooks. BraketLab is being developed by Audun Skau Hansen (a.s.hansen@kjemi.uio.no) at the Department of Chemistry, Hylleraas Centre for Quantum Molecular Sciences, University of Oslo. Background Quantum theory can be learnt in many ways. In a typical introductory course, students get familiar with the shortcomings of classical physics in the microscopic domain and the groundbreaking solutions to these problems found in the 1920s. Through careful attention to rigorous mathematics, logics, formalism and the rules and postulates of quantum theory, students learn how to navigate a world of highly non-intuitive phenomenas. This is an excellent approach, which has fostered generations of highly skilled scientists, pushing the boundaries of science and digging deeper into nature. This is not the only pathway into the quantum world, however. With increased coding-literacy and availability of computational resources, it is natural to explore how computational thinking may aid students in mastering quantum theory. BraketLab is just this; an attempt to shape many computational aids such as numerics and approximative techniques, visualization, object-oriented and high-level programming and interactivity into an environment tailored for learning quantum theory by means of exploration and creativity. Powered by sympy and numpy, BraketLab aims to allow students to easily stray outside of the conventional routes, with a simple syntax closely resembling the one you\u2019ll find in most books on the subject and no complicated integrals to stop them in their tracks. Dependencies Numpy Sympy Matplotlib Numba Py3Dmol Installation Install the BraketLab-module using pip install braketlab from your terminal.","title":"Install"},{"location":"install/#out-of-the-box-outside-of-the-box-thinking","text":"BraketLab is a Python-module for doing quantum theory in Jupyter Notebooks. BraketLab is being developed by Audun Skau Hansen (a.s.hansen@kjemi.uio.no) at the Department of Chemistry, Hylleraas Centre for Quantum Molecular Sciences, University of Oslo.","title":"Out-of-the-box outside-of-the-box thinking"},{"location":"install/#background","text":"Quantum theory can be learnt in many ways. In a typical introductory course, students get familiar with the shortcomings of classical physics in the microscopic domain and the groundbreaking solutions to these problems found in the 1920s. Through careful attention to rigorous mathematics, logics, formalism and the rules and postulates of quantum theory, students learn how to navigate a world of highly non-intuitive phenomenas. This is an excellent approach, which has fostered generations of highly skilled scientists, pushing the boundaries of science and digging deeper into nature. This is not the only pathway into the quantum world, however. With increased coding-literacy and availability of computational resources, it is natural to explore how computational thinking may aid students in mastering quantum theory. BraketLab is just this; an attempt to shape many computational aids such as numerics and approximative techniques, visualization, object-oriented and high-level programming and interactivity into an environment tailored for learning quantum theory by means of exploration and creativity. Powered by sympy and numpy, BraketLab aims to allow students to easily stray outside of the conventional routes, with a simple syntax closely resembling the one you\u2019ll find in most books on the subject and no complicated integrals to stop them in their tracks.","title":"Background"},{"location":"install/#dependencies","text":"Numpy Sympy Matplotlib Numba Py3Dmol","title":"Dependencies"},{"location":"install/#installation","text":"Install the BraketLab-module using pip install braketlab from your terminal.","title":"Installation"},{"location":"installation/","text":"Installing BubbleBox The simplest way of installing BubbleBox is using PyPI: pip install bubblebox Other options is to clone the repository from https://github.com/audunsh/bubblebox and install manually.","title":"Installation"},{"location":"installation/#installing-bubblebox","text":"The simplest way of installing BubbleBox is using PyPI: pip install bubblebox Other options is to clone the repository from https://github.com/audunsh/bubblebox and install manually.","title":"Installing BubbleBox"},{"location":"ising-reference/","text":"Ising module animated_system Support class for animations isingbox __init__ ( self , N , kT , flipratio = 0.1 ) special A 2D (N by N) Ising model Arguments N Lattice dimensions kT Boltsmann factor times the temperature flipratio The ratio of spins to flip at each iteration Methods reset(kT) reset the lattice to all spins aligned, and set kT energy_per_site() compute the energy per site Example usage I = ising(10, kT = 1.0) # an Ising lattice with 10x10 spins, kT = 1.0 I.advance() # do one Monte Carlo integration I.evolve(10) # do 10 Monte Carlo integrations energy = I.compute_energy() # compute energy mangetization = I.compute_magnetization() # compute magnetization energy, magnetization = I.sample(100, 1000) # collect 100 samples, separated by 1000 MC-iterations Source code in bubblebox/ising.py def __init__ ( self , N , kT , flipratio = 0.1 ): \"\"\" A 2D (N by N) Ising model Arguments --- N Lattice dimensions kT Boltsmann factor times the temperature flipratio The ratio of spins to flip at each iteration Methods --- reset(kT) reset the lattice to all spins aligned, and set kT energy_per_site() compute the energy per site Example usage --- I = ising(10, kT = 1.0) # an Ising lattice with 10x10 spins, kT = 1.0 I.advance() # do one Monte Carlo integration I.evolve(10) # do 10 Monte Carlo integrations energy = I.compute_energy() # compute energy mangetization = I.compute_magnetization() # compute magnetization energy, magnetization = I.sample(100, 1000) # collect 100 samples, separated by 1000 MC-iterations \"\"\" self . kT = kT self . N = int ( N ) self . N2 = int ( N ** 2 ) self . Z = np . ones ( self . N ** 2 , dtype = int ) #perhaps not start out in this state? #self.Z[np.random.choice(self.N2, int(self.N2/2), replace = False)] = -1 self . Z_ind = np . arange ( self . N2 ) self . n = int ( flipratio * self . N2 ) self . flipratio = flipratio self . env = self . energy_env_torus () #_torus(arange(self.N2)) self . n_logdist = 1000000 self . logdist = self . kT * np . log ( np . random . uniform ( 0 , 1 , self . n_logdist )) / 2.0 self . t = np . zeros ( 10 , dtype = float ) advance ( self ) Do one Monte Carlo step Source code in bubblebox/ising.py def advance ( self ): \"\"\"Do one Monte Carlo step\"\"\" sel = np . random . choice ( self . N2 , self . n , replace = False ) #bottleneck dz = self . Z [ sel ] denv = self . env [ sel ] dE = dz * denv flips = - dE > self . log_uniform ( self . n ) dz [ flips ] *= - 1 self . Z [ sel ] = dz self . update_env ( 2 * dz [ flips ], sel [ flips ]) #bottleneck compute_energy ( self ) Compute total energy Source code in bubblebox/ising.py def compute_energy ( self ): \"\"\"Compute total energy\"\"\" return - np . sum ( self . Z * self . env ) / 2.0 compute_magnetization ( self ) Compute magnetization Source code in bubblebox/ising.py def compute_magnetization ( self ): \"\"\"Compute magnetization\"\"\" return np . sum ( self . Z ) energy_env_torus ( self ) Compute energy per site for torus PBC Source code in bubblebox/ising.py def energy_env_torus ( self ): \"\"\"Compute energy per site for torus PBC\"\"\" z = self . Z . reshape (( self . N , self . N )) return ( np . roll ( z , 1 , 0 ) + np . roll ( z , - 1 , 0 ) + np . roll ( z , 1 , 1 ) + np . roll ( z , - 1 , 1 )) . ravel () energy_per_site ( self , Z ) Compute sitewise energy (returns a lattice) Source code in bubblebox/ising.py def energy_per_site ( self , Z ): \"\"\"Compute sitewise energy (returns a lattice)\"\"\" return ( Z [ 2 :, 1 : - 1 ] + Z [: - 2 , 1 : - 1 ] + Z [ 1 : - 1 , 2 :] + Z [ 1 : - 1 ,: - 2 ]) #[1:-1,1:-1] evolve ( self , n_steps ) Do n_steps Monte Carlo steps Source code in bubblebox/ising.py def evolve ( self , n_steps ): \"\"\"Do n_steps Monte Carlo steps\"\"\" for i in range ( n_steps ): self . advance () log_uniform ( self , n ) A logarithmic random distribution Source code in bubblebox/ising.py def log_uniform ( self , n ): \"\"\"A logarithmic random distribution\"\"\" return self . logdist [ np . random . randint ( 0 , self . n_logdist , n )] reset ( self , kT ) Reset the system to a non-magnetized state ( |M| = 0 ) and set kT to the specified value Source code in bubblebox/ising.py def reset ( self , kT ): \"\"\" Reset the system to a non-magnetized state ( |M| = 0 ) and set kT to the specified value \"\"\" self . kT = kT self . Z = np . ones ( int ( self . N ** 2 ), dtype = int ) #self.Z[np.random.choice(int(self.N2), int(self.N2/2), replace = False)] = -1 self . Z_ind = np . arange ( self . N2 ) self . n = int ( self . flipratio * self . N2 ) self . env = self . energy_env_torus () run ( self , phase_color = False , n_steps_per_vis = 100 ) Run simulation interactively Source code in bubblebox/ising.py def run ( self , phase_color = False , n_steps_per_vis = 100 ): \"\"\"Run simulation interactively\"\"\" self . run_system = animated_system ( system = self , n_steps_per_vis = n_steps_per_vis , interval = 1 , phase_color = phase_color ) plt . show () sample ( self , n_samples , n_separations ) Collect n_samples separated by n_separations Monte Carlo steps Returns energies_per_site, specific heat, absolute_magnetization_per_site Source code in bubblebox/ising.py def sample ( self , n_samples , n_separations ): \"\"\" Collect n_samples separated by n_separations Monte Carlo steps Returns energies_per_site, specific heat, absolute_magnetization_per_site \"\"\" energy = np . zeros ( n_samples ) magnetization = np . zeros ( n_samples ) energy [ 0 ] = self . compute_energy () magnetization [ 0 ] = self . compute_magnetization () for i in range ( 1 , n_samples ): self . evolve ( n_separations ) energy [ i ] = self . compute_energy () magnetization [ i ] = self . compute_magnetization () return np . mean ( energy ) / self . N2 , np . var ( energy ) / ( self . N2 * self . kT ** 2 ), np . mean ( magnetization ) / self . N2 update_env ( self , signs , z_ind ) update energy environment with a change in Z[z_ind] Source code in bubblebox/ising.py def update_env ( self , signs , z_ind ): \"\"\"update energy environment with a change in Z[z_ind]\"\"\" self . env [ z_ind - 1 ] += signs self . env [( z_ind + 1 ) % self . N2 ] += signs self . env [ z_ind - self . N ] += signs self . env [( z_ind + self . N ) % self . N2 ] += signs","title":"ising"},{"location":"ising-reference/#ising-module","text":"","title":"Ising module"},{"location":"ising-reference/#bubblebox.ising.animated_system","text":"Support class for animations","title":"animated_system"},{"location":"ising-reference/#bubblebox.ising.isingbox","text":"","title":"isingbox"},{"location":"ising-reference/#bubblebox.ising.isingbox.__init__","text":"A 2D (N by N) Ising model","title":"__init__()"},{"location":"ising-reference/#bubblebox.ising.isingbox.__init__--arguments","text":"N Lattice dimensions kT Boltsmann factor times the temperature flipratio The ratio of spins to flip at each iteration","title":"Arguments"},{"location":"ising-reference/#bubblebox.ising.isingbox.__init__--methods","text":"reset(kT) reset the lattice to all spins aligned, and set kT energy_per_site() compute the energy per site","title":"Methods"},{"location":"ising-reference/#bubblebox.ising.isingbox.__init__--example-usage","text":"I = ising(10, kT = 1.0) # an Ising lattice with 10x10 spins, kT = 1.0 I.advance() # do one Monte Carlo integration I.evolve(10) # do 10 Monte Carlo integrations energy = I.compute_energy() # compute energy mangetization = I.compute_magnetization() # compute magnetization energy, magnetization = I.sample(100, 1000) # collect 100 samples, separated by 1000 MC-iterations Source code in bubblebox/ising.py def __init__ ( self , N , kT , flipratio = 0.1 ): \"\"\" A 2D (N by N) Ising model Arguments --- N Lattice dimensions kT Boltsmann factor times the temperature flipratio The ratio of spins to flip at each iteration Methods --- reset(kT) reset the lattice to all spins aligned, and set kT energy_per_site() compute the energy per site Example usage --- I = ising(10, kT = 1.0) # an Ising lattice with 10x10 spins, kT = 1.0 I.advance() # do one Monte Carlo integration I.evolve(10) # do 10 Monte Carlo integrations energy = I.compute_energy() # compute energy mangetization = I.compute_magnetization() # compute magnetization energy, magnetization = I.sample(100, 1000) # collect 100 samples, separated by 1000 MC-iterations \"\"\" self . kT = kT self . N = int ( N ) self . N2 = int ( N ** 2 ) self . Z = np . ones ( self . N ** 2 , dtype = int ) #perhaps not start out in this state? #self.Z[np.random.choice(self.N2, int(self.N2/2), replace = False)] = -1 self . Z_ind = np . arange ( self . N2 ) self . n = int ( flipratio * self . N2 ) self . flipratio = flipratio self . env = self . energy_env_torus () #_torus(arange(self.N2)) self . n_logdist = 1000000 self . logdist = self . kT * np . log ( np . random . uniform ( 0 , 1 , self . n_logdist )) / 2.0 self . t = np . zeros ( 10 , dtype = float )","title":"Example usage"},{"location":"ising-reference/#bubblebox.ising.isingbox.advance","text":"Do one Monte Carlo step Source code in bubblebox/ising.py def advance ( self ): \"\"\"Do one Monte Carlo step\"\"\" sel = np . random . choice ( self . N2 , self . n , replace = False ) #bottleneck dz = self . Z [ sel ] denv = self . env [ sel ] dE = dz * denv flips = - dE > self . log_uniform ( self . n ) dz [ flips ] *= - 1 self . Z [ sel ] = dz self . update_env ( 2 * dz [ flips ], sel [ flips ]) #bottleneck","title":"advance()"},{"location":"ising-reference/#bubblebox.ising.isingbox.compute_energy","text":"Compute total energy Source code in bubblebox/ising.py def compute_energy ( self ): \"\"\"Compute total energy\"\"\" return - np . sum ( self . Z * self . env ) / 2.0","title":"compute_energy()"},{"location":"ising-reference/#bubblebox.ising.isingbox.compute_magnetization","text":"Compute magnetization Source code in bubblebox/ising.py def compute_magnetization ( self ): \"\"\"Compute magnetization\"\"\" return np . sum ( self . Z )","title":"compute_magnetization()"},{"location":"ising-reference/#bubblebox.ising.isingbox.energy_env_torus","text":"Compute energy per site for torus PBC Source code in bubblebox/ising.py def energy_env_torus ( self ): \"\"\"Compute energy per site for torus PBC\"\"\" z = self . Z . reshape (( self . N , self . N )) return ( np . roll ( z , 1 , 0 ) + np . roll ( z , - 1 , 0 ) + np . roll ( z , 1 , 1 ) + np . roll ( z , - 1 , 1 )) . ravel ()","title":"energy_env_torus()"},{"location":"ising-reference/#bubblebox.ising.isingbox.energy_per_site","text":"Compute sitewise energy (returns a lattice) Source code in bubblebox/ising.py def energy_per_site ( self , Z ): \"\"\"Compute sitewise energy (returns a lattice)\"\"\" return ( Z [ 2 :, 1 : - 1 ] + Z [: - 2 , 1 : - 1 ] + Z [ 1 : - 1 , 2 :] + Z [ 1 : - 1 ,: - 2 ]) #[1:-1,1:-1]","title":"energy_per_site()"},{"location":"ising-reference/#bubblebox.ising.isingbox.evolve","text":"Do n_steps Monte Carlo steps Source code in bubblebox/ising.py def evolve ( self , n_steps ): \"\"\"Do n_steps Monte Carlo steps\"\"\" for i in range ( n_steps ): self . advance ()","title":"evolve()"},{"location":"ising-reference/#bubblebox.ising.isingbox.log_uniform","text":"A logarithmic random distribution Source code in bubblebox/ising.py def log_uniform ( self , n ): \"\"\"A logarithmic random distribution\"\"\" return self . logdist [ np . random . randint ( 0 , self . n_logdist , n )]","title":"log_uniform()"},{"location":"ising-reference/#bubblebox.ising.isingbox.reset","text":"Reset the system to a non-magnetized state ( |M| = 0 ) and set kT to the specified value Source code in bubblebox/ising.py def reset ( self , kT ): \"\"\" Reset the system to a non-magnetized state ( |M| = 0 ) and set kT to the specified value \"\"\" self . kT = kT self . Z = np . ones ( int ( self . N ** 2 ), dtype = int ) #self.Z[np.random.choice(int(self.N2), int(self.N2/2), replace = False)] = -1 self . Z_ind = np . arange ( self . N2 ) self . n = int ( self . flipratio * self . N2 ) self . env = self . energy_env_torus ()","title":"reset()"},{"location":"ising-reference/#bubblebox.ising.isingbox.run","text":"Run simulation interactively Source code in bubblebox/ising.py def run ( self , phase_color = False , n_steps_per_vis = 100 ): \"\"\"Run simulation interactively\"\"\" self . run_system = animated_system ( system = self , n_steps_per_vis = n_steps_per_vis , interval = 1 , phase_color = phase_color ) plt . show ()","title":"run()"},{"location":"ising-reference/#bubblebox.ising.isingbox.sample","text":"Collect n_samples separated by n_separations Monte Carlo steps Returns energies_per_site, specific heat, absolute_magnetization_per_site Source code in bubblebox/ising.py def sample ( self , n_samples , n_separations ): \"\"\" Collect n_samples separated by n_separations Monte Carlo steps Returns energies_per_site, specific heat, absolute_magnetization_per_site \"\"\" energy = np . zeros ( n_samples ) magnetization = np . zeros ( n_samples ) energy [ 0 ] = self . compute_energy () magnetization [ 0 ] = self . compute_magnetization () for i in range ( 1 , n_samples ): self . evolve ( n_separations ) energy [ i ] = self . compute_energy () magnetization [ i ] = self . compute_magnetization () return np . mean ( energy ) / self . N2 , np . var ( energy ) / ( self . N2 * self . kT ** 2 ), np . mean ( magnetization ) / self . N2","title":"sample()"},{"location":"ising-reference/#bubblebox.ising.isingbox.update_env","text":"update energy environment with a change in Z[z_ind] Source code in bubblebox/ising.py def update_env ( self , signs , z_ind ): \"\"\"update energy environment with a change in Z[z_ind]\"\"\" self . env [ z_ind - 1 ] += signs self . env [( z_ind + 1 ) % self . N2 ] += signs self . env [ z_ind - self . N ] += signs self . env [( z_ind + self . N ) % self . N2 ] += signs","title":"update_env()"},{"location":"lattice_models-reference/","text":"Lattice models module lattice energy ( self , lattice = None ) Computes the energy of the lattice (if no lattice provided, the energy of self.lattice is computed) Source code in bubblebox/lattice_models.py def energy ( self , lattice = None ): \"\"\" Computes the energy of the lattice (if no lattice provided, the energy of self.lattice is computed) \"\"\" if lattice is None : lattice = self . lattice energy = 0 #for i in range(lattice.shape[0]-1): # for j in range(lattice.shape[1]-1): # if np.abs(lattice[i,j] - lattice[i,j+1]) == 1: # energy += 1 # if np.abs(lattice[i,j] - lattice[i+1,j]) == 1: # energy += 1 return np . sum ( np . abs ( lattice [ 1 :,:] - lattice [: - 1 ,:]) == 1 ) + np . sum ( np . abs ( lattice [:, 1 :] - lattice [:, : - 1 ]) == 1 ) find_all_possible_placements ( self , polym , uniques = True ) Returns all (unique) possible conformations of polym that fit in the lattice Source code in bubblebox/lattice_models.py def find_all_possible_placements ( self , polym , uniques = True ): \"\"\" Returns all (unique) possible conformations of polym that fit in the lattice \"\"\" config = [ self . _edict [ k ] for k in polym . config ] valid_conformations = [] unique_lattices = [] for i in range ( self . lattice . shape [ 0 ]): for j in range ( self . lattice . shape [ 1 ]): if self . lattice [ i , j ] == - 1 : for ci in range ( len ( polym . conformations )): c = polym . conformations [ ci ] if self . validate_placement ( i , j , c ): conf = [ np . array ([ i , j ])] + c conf = np . cumsum ( np . array ( conf ), axis = 0 ) # determine if conformation is unique conf_unique = True for k in valid_conformations : if np . sum (( k - conf ) ** 2 ) == 0 : conf_unique = False if conf_unique : valid_conformations . append ( conf ) #, self.place_polymer_at(i,j,polym, c)]) #unique_lattices.append(lat) return valid_conformations place_polymer_at ( self , i , j , polym , conformation = None ) Returns a lattice where polymer is placed at coordinates i,j in lattice If no conformation is specified the function will chose the first available conformation which fits. Source code in bubblebox/lattice_models.py def place_polymer_at ( self , i , j , polym , conformation = None ): \"\"\" Returns a lattice where polymer is placed at coordinates i,j in lattice If no conformation is specified the function will chose the first available conformation which fits. \"\"\" assert ( i < self . lattice . shape [ 0 ]), \"invalid placement\" assert ( j < self . lattice . shape [ 1 ]), \"invalid placement\" config = [ self . _edict [ k ] for k in polym . config ] lattice = self . lattice * 1 if conformation is None : placed = False for c in range ( len ( polym . conformations )): pc = polym . conformations [ c ] if self . validate_placement ( i , j , pc ): placed = True print ( pc ) # place polymer di , dj = i , j lattice [ di , dj ] = self . _edict [ polym . config [ 0 ]] for k in range ( len ( polym . conformations [ c ])): di += polym . conformations [ c ][ k ][ 0 ] dj += polym . conformations [ c ][ k ][ 1 ] lattice [ di , dj ] = self . _edict [ polym . config [ k + 1 ]] if not placed : print ( \"Unable to fit polymer in lattice\" ) else : if self . validate_placement ( i , j , conformation ): di , dj = i , j lattice [ di , dj ] = self . _edict [ polym . config [ 0 ]] for k in range ( len ( conformation )): di += conformation [ k ][ 0 ] dj += conformation [ k ][ 1 ] lattice [ di , dj ] = self . _edict [ polym . config [ k + 1 ]] else : print ( \"Conformation does not fit in lattice\" ) return lattice validate_placement ( self , i , j , conf ) Only sites with water are replaced Source code in bubblebox/lattice_models.py def validate_placement ( self , i , j , conf ): \"\"\" Only sites with water are replaced \"\"\" if self . lattice [ i , j ] !=- 1 : return False di , dj = i , j for c in conf : di , dj = di + c [ 0 ], dj + c [ 1 ] if self . lattice [ di , dj ] !=- 1 or di < 0 or dj < 0 : return False return True latticebox Lattice model advance ( self ) One Metropolis-Hastings step Source code in bubblebox/lattice_models.py def advance ( self ): \"\"\" One Metropolis-Hastings step \"\"\" # pick some pairs at random i , j = np . random . choice ( self . lattice . size , 2 * self . n_swaps_per_advance , replace = False ) . reshape ( 2 , - 1 ) new_lattice = np . zeros_like ( self . lattice ) new_lattice [:] = self . lattice [:] #perform swap new_lattice . flat [ i ] = self . lattice . flat [ j ] new_lattice . flat [ j ] = self . lattice . flat [ i ] E = self . energy ( lattice = new_lattice ) dE = E - self . E if np . exp ( - dE / self . kT ) > np . random . uniform ( 0 , 1 ): # accept move self . lattice = new_lattice self . E = E advance_detailed ( self ) One Metropolis-Hastings step Source code in bubblebox/lattice_models.py def advance_detailed ( self ): \"\"\" One Metropolis-Hastings step \"\"\" # if only neighbors are allowed to swap if self . neighbor_swap : i = np . random . choice ( self . lattice . size , self . n_swaps_per_advance , replace = False ) ir = np . array ( np . unravel_index ( i , self . lattice . shape ), dtype = int ) jr = ( ir + ( np . array ([[ 1 , 0 ], [ 0 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ]])[ np . random . randint ( 0 , 4 , self . n_swaps_per_advance )]) . T ) % np . array ( self . lattice . shape )[:, None ] j = np . ravel_multi_index ( jr , self . lattice . shape ) else : # pick self.n_swaps_per_advance number of pairs i , j = np . random . choice ( self . lattice . size , 2 * self . n_swaps_per_advance , replace = False ) . reshape ( 2 , - 1 ) li = self . lattice . flat [ i ] lj = self . lattice . flat [ j ] # remove all cases where li == lj # local energies before and after swaps energies = np . zeros (( 2 , self . n_swaps_per_advance )) if np . any ( li != lj ): ir = np . array ( np . unravel_index ( i , self . lattice . shape ), dtype = int ) jr = np . array ( np . unravel_index ( j , self . lattice . shape ), dtype = int ) ax = np . zeros ( len ( self . lattice . shape ), dtype = int ) ax [ 0 ] = 1 for k in range ( len ( self . lattice . shape )): # current energy in i-points dr = np . roll ( ax , k , axis = 0 )[:, None ] neighbors_plus = ( ir + dr ) % np . array ( self . lattice . shape )[:, None ] neighbors_min = ( ir - dr ) % np . array ( self . lattice . shape )[:, None ] p_p = self . lattice [ tuple ( neighbors_plus )] m_p = self . lattice [ tuple ( neighbors_min )] energies [ 0 ] += self . interaction [ li , p_p ] energies [ 0 ] += self . interaction [ li , m_p ] #swapped energy in i-points energies [ 1 ] += self . interaction [ lj , p_p ] energies [ 1 ] += self . interaction [ lj , m_p ] # current energy in j-points neighbors_plus = ( jr + dr ) % np . array ( self . lattice . shape )[:, None ] neighbors_min = ( jr - dr ) % np . array ( self . lattice . shape )[:, None ] p_p = self . lattice [ tuple ( neighbors_plus )] m_p = self . lattice [ tuple ( neighbors_min )] energies [ 0 ] += self . interaction [ lj , p_p ] energies [ 0 ] += self . interaction [ lj , m_p ] #swapped energy in j-points energies [ 1 ] += self . interaction [ li , p_p ] energies [ 1 ] += self . interaction [ li , m_p ] # allow swaps depending on energy difference dE = energies [ 1 ] - energies [ 0 ] # if energy change is negative, accept move #swaps_for_sure = dE<0 #self.lattice.flat[i[swaps_for_sure]] = lj[swaps_for_sure] #self.lattice.flat[j[swaps_for_sure]] = li[swaps_for_sure] # if not, accept with a probability depending on the energy difference swaps = np . exp ( - dE / self . kT ) > np . random . uniform ( 0 , 1 , self . n_swaps_per_advance ) swaps [ li == lj ] = False #print(dE[li == lj]) #print(dE[li != lj]) #print(np.exp(-dE/self.kT)) #swaps[swaps_for_sure] = False #these have already been swapped self . lattice . flat [ i [ swaps ]] = lj [ swaps ] self . lattice . flat [ j [ swaps ]] = li [ swaps ] self . iterations += 1 energy ( self , lattice = None ) compute the energy of the entire lattice Source code in bubblebox/lattice_models.py def energy ( self , lattice = None ): \"\"\" compute the energy of the entire lattice \"\"\" if lattice is None : lattice = self . lattice energy = 0 for i in range ( len ( lattice . shape )): energy += self . interaction [ np . roll ( lattice , 1 , axis = i ) . ravel (), lattice . ravel ()] . sum () return energy energy_at_site ( self , i , li = None ) Compute energy at site Source code in bubblebox/lattice_models.py def energy_at_site ( self , i , li = None ): \"\"\" Compute energy at site \"\"\" dl = np . zeros ( len ( self . lattice . shape ), dtype = int ) dl [ 0 ] = 1 energy = np . zeros (( 2 , self . n_swaps_per_advance )) for m in range ( len ( self . lattice . shape )): #print(self.lattice[tuple(i)], i) if li is None : li = self . lattice [ tuple ( i )] #print(\"li:\", li) #print(\"i :\", i) #print(self.interaction[[self.lattice[tuple(i)], li], self.lattice[tuple((i+np.roll(dl, m))%self.lattice.shape)]]) #print(\"e:\", i, li) #energy += self.interaction[[self.lattice[tuple(i)], li], self.lattice[tuple((i+np.roll(dl, m))%self.lattice.shape)]] #energy += self.interaction[[self.lattice[tuple(i)], li], self.lattice[tuple((i-np.roll(dl, m))%self.lattice.shape)]] #print(self.interaction[[self.lattice[i], li], self.lattice[tuple((i+np.roll(dl, m))%self.lattice.shape)]]) energy += self . interaction [[ self . lattice [ i ], li ], self . lattice [ tuple (( i + np . roll ( dl , m )) % self . lattice . shape )]] energy += self . interaction [[ self . lattice [ i ], li ], self . lattice [ tuple (( i - np . roll ( dl , m )) % self . lattice . shape )]] return energy sample ( self ) update measurements Source code in bubblebox/lattice_models.py def sample ( self ): \"\"\"update measurements\"\"\" self . s_energy = ( self . s_energy * self . samples + self . energy ()) / ( self . samples + 1 ) self . samples += 1 return self . energy polymer advance_conformation ( self , conformation , points ) Recurrent function for discovering possible conformations. Source code in bubblebox/lattice_models.py def advance_conformation ( self , conformation , points ): \"\"\" Recurrent function for discovering possible conformations. \"\"\" if len ( conformation ) >= len ( self . config ) - 1 : self . conformations . append ( conformation ) else : for i in self . basis : #if not np.all(i == -1*conformation[-1]): if np . sum (( i + conformation [ - 1 ]) ** 2 ) > 0 : new_point = points [ - 1 ] + i if not np . any ( np . sum ( np . abs ( new_point - points ), axis = 1 ) == 0 ): # and np.sum(new_point**2)>0: new_points = points + [ new_point ] new_conformation = conformation + [ i ] self . advance_conformation ( new_conformation , new_points ) determine_conformations ( self ) Explore and determine possible conformations Note The generated conformations contain a lot of redundancy due to symmetries. However, we simply want a set which is compact enough for a somewhat efficient exploration of small polymers. Source code in bubblebox/lattice_models.py def determine_conformations ( self ): \"\"\" Explore and determine possible conformations **Note** The generated conformations contain a lot of redundancy due to symmetries. However, we simply want a set which is compact enough for a somewhat efficient exploration of small polymers. \"\"\" self . advance_conformation ([ np . array ([ 1 , 0 ])], [ np . array ([ 0 , 0 ]), np . array ([ 1 , 0 ])]) # generate transformed conformations transformed_conformations = [] for i in self . conformations : transformed_conformations . append ( i ) transformed_conformations . append ([ np . array ([ j [ 0 ], - j [ 1 ]]) for j in i ]) transformed_conformations . append ([ np . array ([ - j [ 0 ], j [ 1 ]]) for j in i ]) transformed_conformations . append ([ np . array ([ - j [ 0 ], - j [ 1 ]]) for j in i ]) transformed_conformations . append ([ np . array ([ j [ 1 ], j [ 0 ]]) for j in i ]) transformed_conformations . append ([ np . array ([ - j [ 1 ], j [ 0 ]]) for j in i ]) transformed_conformations . append ([ np . array ([ j [ 1 ], - j [ 0 ]]) for j in i ]) transformed_conformations . append ([ np . array ([ - j [ 1 ], - j [ 0 ]]) for j in i ]) self . conformations = transformed_conformations equilibrate ( l , n_thresh = 100000.0 , dn = 2000 , thresh = 2e-05 ) Equilibrate a lattice system Aaguments n_thresh = number of iterations before we start accumulating energy dn = number of iterations between each sample thresh = assume equilibrated when relative change in energy falls below this threshold Source code in bubblebox/lattice_models.py def equilibrate ( l , n_thresh = 1e5 , dn = 2000 , thresh = 2e-5 ): \"\"\" Equilibrate a lattice system Aaguments n_thresh = number of iterations before we start accumulating energy dn = number of iterations between each sample thresh = assume equilibrated when relative change in energy falls below this threshold \"\"\" # first, move system towards equilibrium # before we start sampling l . evolve ( int ( n_thresh )) # then start sampling the energy n_samples = 0 #number of samples energy_ac = 0 #accumulated energy for i in range ( 200 ): l . evolve ( dn ) ei = l . energy () / l . lattice . size #compute the lattice energy per particle energy_ac_prev = energy_ac #retain previous energy energy_ac = ( energy_ac * n_samples + ei ) / ( n_samples + 1 ) #update accumulated mean energy n_samples += 1 #update number of samples # compute relative change relative_change_in_energy = ( energy_ac - energy_ac_prev ) / energy_ac if np . abs ( relative_change_in_energy ) < thresh : # if relative change in energy is below thresh, # return the equilibrated lattice #print(\"Equilibrated lattice with %i samples, final relative change in energy: %.10e\" % (n_samples, relative_change_in_energy)) return l print ( \"Failed to equilibrate\" ) return l order_2d ( l ) for each site on the lattice, measure the number of differing neighbors should be used after equilibration Source code in bubblebox/lattice_models.py def order_2d ( l ): \"\"\" for each site on the lattice, measure the number of differing neighbors should be used after equilibration \"\"\" # compute absolute differences between neighboring sites lnn = 1 - np . abs ( l . lattice - np . roll ( l . lattice , 1 , axis = 0 )) lnn += 1 - np . abs ( l . lattice - np . roll ( l . lattice , - 1 , axis = 0 )) lnn += 1 - np . abs ( l . lattice - np . roll ( l . lattice , 1 , axis = 1 )) lnn += 1 - np . abs ( l . lattice - np . roll ( l . lattice , - 1 , axis = 1 )) # for species A lnn_A = lnn [ l . lattice == 0 ] lnn_A_bins = np . bincount ( lnn_A ) # should be 1 if A perfectly separated # should be 0.5 if perfectly mixed # for species B lnn_B = lnn [ l . lattice == 1 ] lnn_B_bins = np . bincount ( lnn_B ) \"\"\" #summarize results for i in range(len(lnn_A_bins)): print(\"A fraction of %.3f of species A have %i neighbors different than itself \" % (lnn_A_bins[i]/l.number_of_species[0], i)) print(\" \") for i in range(len(lnn_B_bins)): print(\"A fraction of %.3f of species B have %i neighbors different than itself \" % (lnn_B_bins[i]/l.number_of_species[1], i)) \"\"\" # if we only count sites surrounded by at least three molecules # identical to the one occupying the site as being in phase A or B, # and the remaining ones in liquid phase, we can return the following estimates # notice, however, that this is a matter of interpretation n_in_phase_A = lnn_A_bins [: 1 ] . sum () n_in_phase_B = lnn_B_bins [: 1 ] . sum () n_in_mixed_phase = lnn_A_bins [ 1 :] . sum () + lnn_B_bins [ 1 :] . sum () return lnn_A . mean () / 4.0 order_nd ( l ) for each site on the lattice, measure the number of differing neighbors should be used after equilibration Source code in bubblebox/lattice_models.py def order_nd ( l ): \"\"\" for each site on the lattice, measure the number of differing neighbors should be used after equilibration \"\"\" # compute absolute differences between neighboring sites lnn = np . zeros_like ( l . lattice ) for i in range ( len ( l . lattice . shape )): lnn += 1 - np . abs ( l . lattice - np . roll ( l . lattice , 1 , axis = i )) lnn += 1 - np . abs ( l . lattice - np . roll ( l . lattice , - 1 , axis = i )) # for species A lnn_A = lnn #[l.lattice==0] lnn_A_bins = np . bincount ( lnn_A . ravel ()) #print(lnn_A_bins/np.sum(l.lattice==0)) # should be 1 if A perfectly separated # should be 0.5 if perfectly mixed #return lnn_A.mean()/(2*nd) return lnn_A_bins / np . sum ( lnn_A_bins ), np . mean ( lnn ) remove_rotational_redundance ( conf , remove_reversed = False ) Remove rotational redundancies from the set of conformations conf Source code in bubblebox/lattice_models.py def remove_rotational_redundance ( conf , remove_reversed = False ): \"\"\" Remove rotational redundancies from the set of conformations conf \"\"\" nonredundant_set = [] #nonredundant conformations to be added here for c in conf : nonredundant = True # if nonredundant, add to nonredundant_set cc = np . array ( c ) # check for redundancies for m in nonredundant_set : mc = np . array ( m ) for j in range ( 4 ): if np . sum (( mc - cc ) ** 2 ) < 1e-10 : nonredundant = False cc = cc . dot ( np . array ([[ 0 , 1 ],[ - 1 , 0 ]])) #rotate polymer 90 degrees if remove_reversed : cc = cc [:: - 1 ] # reverse polymer for j in range ( 4 ): if np . sum (( mc - cc ) ** 2 ) < 1e-10 : nonredundant = False cc = cc . dot ( np . array ([[ 0 , 1 ],[ - 1 , 0 ]])) if nonredundant : nonredundant_set . append ( c ) return nonredundant_set show_conformations ( polym ) Show all possible conformations of polym(er) Source code in bubblebox/lattice_models.py def show_conformations ( polym ): \"\"\" Show all possible conformations of polym(er) \"\"\" n = int ( np . sqrt ( len ( polym . conformations )) + 1 ) sep = 6.5 plt . figure ( figsize = ( 10 , 10 )) c = 0 lp = len ( polym . conformations ) hi = np . array ([ i for i in polym . config ]) == \"H\" pi = np . array ([ i for i in polym . config ]) == \"P\" for i in range ( n ): for j in range ( n ): if c < lp : conf = [ np . array ([ 0 , 0 ])] + polym . conformations [ c ] conf = np . cumsum ( np . array ( conf ), axis = 0 ) conf = conf - np . mean ( conf , axis = 0 )[ None , :] plt . plot ( conf [:, 0 ] + i * sep , conf [:, 1 ] - j * sep , \"-\" , color = ( 0 , 0 , 0 )) plt . plot ( conf [ hi , 0 ] + i * sep , conf [ hi , 1 ] - j * sep , \"o\" , color = ( .8 , .3 , 0 ), markersize = 2 ) plt . plot ( conf [ pi , 0 ] + i * sep , conf [ pi , 1 ] - j * sep , \"o\" , color = ( 0 , .3 , .8 ), markersize = 2 ) c += 1 plt . xlim ( - sep , sep * n + 1 ) plt . ylim ( - sep * n , sep ) plt . axis ( \"off\" ) plt . show () show_lattice_placement ( l , p , c ) Show how the lattice l looks when polymer p is placed as defined by positions c Source code in bubblebox/lattice_models.py def show_lattice_placement ( l , p , c ): \"\"\" Show how the lattice l looks when polymer p is placed as defined by positions c \"\"\" if type ( c ) is not list : c = [ c ] n = int ( np . sqrt ( len ( c )) + 1 ) counter = 0 plt . figure ( figsize = ( 2 * l . lattice . shape [ 0 ], 2 * l . lattice . shape [ 1 ])) dx , dy = l . lattice . shape [ 1 ] + 3 , l . lattice . shape [ 0 ] + 3 unique_lattices = [] #list to hold unique lattice configurations for i in range ( n ): for j in range ( n ): if counter < len ( c ): #compute energy of polymer energy_polymer = p . energy () #compute energy of empty cavity energy_cavity = l . energy () pts = np . array ( np . meshgrid ( np . arange ( l . lattice . shape [ 1 ]) + dx * i , np . arange ( l . lattice . shape [ 0 ]) + dy * j )) . reshape ( 2 , - 1 ) . T lat = l . lattice * 1 config = [ l . _edict [ k ] for k in p . config ] lat [ c [ counter ][:, 0 ], c [ counter ][:, 1 ]] = config # compute energy of filled cavity energy_filled = l . energy ( lat ) lat = lat . ravel () lw = lat ==- 1 lh = lat == 0 lp = lat == 1 plt . plot ( pts [ lw , 1 ], pts [ lw , 0 ], \"o\" , markersize = 5 , color = ( .3 , .3 , .8 )) plt . plot ( pts [ lh , 1 ], pts [ lh , 0 ], \"o\" , markersize = 5 , color = ( .9 , .9 , .3 )) plt . plot ( pts [ lp , 1 ], pts [ lp , 0 ], \"o\" , markersize = 5 , color = ( .8 , .4 , .3 )) plt . plot ( pts [ lw , 1 ], pts [ lw , 0 ], \"o\" , markersize = 7 , color = ( 0 , 0 , 0 ), zorder = - 1 ) plt . plot ( pts [ lh , 1 ], pts [ lh , 0 ], \"o\" , markersize = 7 , color = ( 0 , 0 , 0 ), zorder = - 1 ) plt . plot ( pts [ lp , 1 ], pts [ lp , 0 ], \"o\" , markersize = 7 , color = ( 0 , 0 , 0 ), zorder = - 1 ) plt . plot ( c [ counter ][:, 0 ] + dy * j , c [ counter ][:, 1 ] + dx * i , \"-\" , color = ( 0 , 0 , 0 ), zorder = - 1 , linewidth = 2 ) #print(\"Polymer self-energy :\", energy_polymer) #print(\"Energy of empty cavity :\", energy_cavity) #print(\"Energy of filled cavity:\", energy_filled) #print(\"Total energy. :\", energy_filled - energy_cavity - energy_polymer) plt . text ( dy * ( j + .25 ), dx * i - 1 , \"$\\epsilon$ = %i \" % ( energy_filled - energy_cavity - energy_polymer ), ha = \"center\" , va = \"center\" , fontsize = 8 ) counter += 1 plt . axis ( \"off\" ) plt . show ()","title":"lattice_models"},{"location":"lattice_models-reference/#lattice-models-module","text":"","title":"Lattice models module"},{"location":"lattice_models-reference/#bubblebox.lattice_models.lattice","text":"","title":"lattice"},{"location":"lattice_models-reference/#bubblebox.lattice_models.lattice.energy","text":"Computes the energy of the lattice (if no lattice provided, the energy of self.lattice is computed) Source code in bubblebox/lattice_models.py def energy ( self , lattice = None ): \"\"\" Computes the energy of the lattice (if no lattice provided, the energy of self.lattice is computed) \"\"\" if lattice is None : lattice = self . lattice energy = 0 #for i in range(lattice.shape[0]-1): # for j in range(lattice.shape[1]-1): # if np.abs(lattice[i,j] - lattice[i,j+1]) == 1: # energy += 1 # if np.abs(lattice[i,j] - lattice[i+1,j]) == 1: # energy += 1 return np . sum ( np . abs ( lattice [ 1 :,:] - lattice [: - 1 ,:]) == 1 ) + np . sum ( np . abs ( lattice [:, 1 :] - lattice [:, : - 1 ]) == 1 )","title":"energy()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.lattice.find_all_possible_placements","text":"Returns all (unique) possible conformations of polym that fit in the lattice Source code in bubblebox/lattice_models.py def find_all_possible_placements ( self , polym , uniques = True ): \"\"\" Returns all (unique) possible conformations of polym that fit in the lattice \"\"\" config = [ self . _edict [ k ] for k in polym . config ] valid_conformations = [] unique_lattices = [] for i in range ( self . lattice . shape [ 0 ]): for j in range ( self . lattice . shape [ 1 ]): if self . lattice [ i , j ] == - 1 : for ci in range ( len ( polym . conformations )): c = polym . conformations [ ci ] if self . validate_placement ( i , j , c ): conf = [ np . array ([ i , j ])] + c conf = np . cumsum ( np . array ( conf ), axis = 0 ) # determine if conformation is unique conf_unique = True for k in valid_conformations : if np . sum (( k - conf ) ** 2 ) == 0 : conf_unique = False if conf_unique : valid_conformations . append ( conf ) #, self.place_polymer_at(i,j,polym, c)]) #unique_lattices.append(lat) return valid_conformations","title":"find_all_possible_placements()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.lattice.place_polymer_at","text":"Returns a lattice where polymer is placed at coordinates i,j in lattice If no conformation is specified the function will chose the first available conformation which fits. Source code in bubblebox/lattice_models.py def place_polymer_at ( self , i , j , polym , conformation = None ): \"\"\" Returns a lattice where polymer is placed at coordinates i,j in lattice If no conformation is specified the function will chose the first available conformation which fits. \"\"\" assert ( i < self . lattice . shape [ 0 ]), \"invalid placement\" assert ( j < self . lattice . shape [ 1 ]), \"invalid placement\" config = [ self . _edict [ k ] for k in polym . config ] lattice = self . lattice * 1 if conformation is None : placed = False for c in range ( len ( polym . conformations )): pc = polym . conformations [ c ] if self . validate_placement ( i , j , pc ): placed = True print ( pc ) # place polymer di , dj = i , j lattice [ di , dj ] = self . _edict [ polym . config [ 0 ]] for k in range ( len ( polym . conformations [ c ])): di += polym . conformations [ c ][ k ][ 0 ] dj += polym . conformations [ c ][ k ][ 1 ] lattice [ di , dj ] = self . _edict [ polym . config [ k + 1 ]] if not placed : print ( \"Unable to fit polymer in lattice\" ) else : if self . validate_placement ( i , j , conformation ): di , dj = i , j lattice [ di , dj ] = self . _edict [ polym . config [ 0 ]] for k in range ( len ( conformation )): di += conformation [ k ][ 0 ] dj += conformation [ k ][ 1 ] lattice [ di , dj ] = self . _edict [ polym . config [ k + 1 ]] else : print ( \"Conformation does not fit in lattice\" ) return lattice","title":"place_polymer_at()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.lattice.validate_placement","text":"Only sites with water are replaced Source code in bubblebox/lattice_models.py def validate_placement ( self , i , j , conf ): \"\"\" Only sites with water are replaced \"\"\" if self . lattice [ i , j ] !=- 1 : return False di , dj = i , j for c in conf : di , dj = di + c [ 0 ], dj + c [ 1 ] if self . lattice [ di , dj ] !=- 1 or di < 0 or dj < 0 : return False return True","title":"validate_placement()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.latticebox","text":"Lattice model","title":"latticebox"},{"location":"lattice_models-reference/#bubblebox.lattice_models.latticebox.advance","text":"One Metropolis-Hastings step Source code in bubblebox/lattice_models.py def advance ( self ): \"\"\" One Metropolis-Hastings step \"\"\" # pick some pairs at random i , j = np . random . choice ( self . lattice . size , 2 * self . n_swaps_per_advance , replace = False ) . reshape ( 2 , - 1 ) new_lattice = np . zeros_like ( self . lattice ) new_lattice [:] = self . lattice [:] #perform swap new_lattice . flat [ i ] = self . lattice . flat [ j ] new_lattice . flat [ j ] = self . lattice . flat [ i ] E = self . energy ( lattice = new_lattice ) dE = E - self . E if np . exp ( - dE / self . kT ) > np . random . uniform ( 0 , 1 ): # accept move self . lattice = new_lattice self . E = E","title":"advance()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.latticebox.advance_detailed","text":"One Metropolis-Hastings step Source code in bubblebox/lattice_models.py def advance_detailed ( self ): \"\"\" One Metropolis-Hastings step \"\"\" # if only neighbors are allowed to swap if self . neighbor_swap : i = np . random . choice ( self . lattice . size , self . n_swaps_per_advance , replace = False ) ir = np . array ( np . unravel_index ( i , self . lattice . shape ), dtype = int ) jr = ( ir + ( np . array ([[ 1 , 0 ], [ 0 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ]])[ np . random . randint ( 0 , 4 , self . n_swaps_per_advance )]) . T ) % np . array ( self . lattice . shape )[:, None ] j = np . ravel_multi_index ( jr , self . lattice . shape ) else : # pick self.n_swaps_per_advance number of pairs i , j = np . random . choice ( self . lattice . size , 2 * self . n_swaps_per_advance , replace = False ) . reshape ( 2 , - 1 ) li = self . lattice . flat [ i ] lj = self . lattice . flat [ j ] # remove all cases where li == lj # local energies before and after swaps energies = np . zeros (( 2 , self . n_swaps_per_advance )) if np . any ( li != lj ): ir = np . array ( np . unravel_index ( i , self . lattice . shape ), dtype = int ) jr = np . array ( np . unravel_index ( j , self . lattice . shape ), dtype = int ) ax = np . zeros ( len ( self . lattice . shape ), dtype = int ) ax [ 0 ] = 1 for k in range ( len ( self . lattice . shape )): # current energy in i-points dr = np . roll ( ax , k , axis = 0 )[:, None ] neighbors_plus = ( ir + dr ) % np . array ( self . lattice . shape )[:, None ] neighbors_min = ( ir - dr ) % np . array ( self . lattice . shape )[:, None ] p_p = self . lattice [ tuple ( neighbors_plus )] m_p = self . lattice [ tuple ( neighbors_min )] energies [ 0 ] += self . interaction [ li , p_p ] energies [ 0 ] += self . interaction [ li , m_p ] #swapped energy in i-points energies [ 1 ] += self . interaction [ lj , p_p ] energies [ 1 ] += self . interaction [ lj , m_p ] # current energy in j-points neighbors_plus = ( jr + dr ) % np . array ( self . lattice . shape )[:, None ] neighbors_min = ( jr - dr ) % np . array ( self . lattice . shape )[:, None ] p_p = self . lattice [ tuple ( neighbors_plus )] m_p = self . lattice [ tuple ( neighbors_min )] energies [ 0 ] += self . interaction [ lj , p_p ] energies [ 0 ] += self . interaction [ lj , m_p ] #swapped energy in j-points energies [ 1 ] += self . interaction [ li , p_p ] energies [ 1 ] += self . interaction [ li , m_p ] # allow swaps depending on energy difference dE = energies [ 1 ] - energies [ 0 ] # if energy change is negative, accept move #swaps_for_sure = dE<0 #self.lattice.flat[i[swaps_for_sure]] = lj[swaps_for_sure] #self.lattice.flat[j[swaps_for_sure]] = li[swaps_for_sure] # if not, accept with a probability depending on the energy difference swaps = np . exp ( - dE / self . kT ) > np . random . uniform ( 0 , 1 , self . n_swaps_per_advance ) swaps [ li == lj ] = False #print(dE[li == lj]) #print(dE[li != lj]) #print(np.exp(-dE/self.kT)) #swaps[swaps_for_sure] = False #these have already been swapped self . lattice . flat [ i [ swaps ]] = lj [ swaps ] self . lattice . flat [ j [ swaps ]] = li [ swaps ] self . iterations += 1","title":"advance_detailed()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.latticebox.energy","text":"compute the energy of the entire lattice Source code in bubblebox/lattice_models.py def energy ( self , lattice = None ): \"\"\" compute the energy of the entire lattice \"\"\" if lattice is None : lattice = self . lattice energy = 0 for i in range ( len ( lattice . shape )): energy += self . interaction [ np . roll ( lattice , 1 , axis = i ) . ravel (), lattice . ravel ()] . sum () return energy","title":"energy()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.latticebox.energy_at_site","text":"Compute energy at site Source code in bubblebox/lattice_models.py def energy_at_site ( self , i , li = None ): \"\"\" Compute energy at site \"\"\" dl = np . zeros ( len ( self . lattice . shape ), dtype = int ) dl [ 0 ] = 1 energy = np . zeros (( 2 , self . n_swaps_per_advance )) for m in range ( len ( self . lattice . shape )): #print(self.lattice[tuple(i)], i) if li is None : li = self . lattice [ tuple ( i )] #print(\"li:\", li) #print(\"i :\", i) #print(self.interaction[[self.lattice[tuple(i)], li], self.lattice[tuple((i+np.roll(dl, m))%self.lattice.shape)]]) #print(\"e:\", i, li) #energy += self.interaction[[self.lattice[tuple(i)], li], self.lattice[tuple((i+np.roll(dl, m))%self.lattice.shape)]] #energy += self.interaction[[self.lattice[tuple(i)], li], self.lattice[tuple((i-np.roll(dl, m))%self.lattice.shape)]] #print(self.interaction[[self.lattice[i], li], self.lattice[tuple((i+np.roll(dl, m))%self.lattice.shape)]]) energy += self . interaction [[ self . lattice [ i ], li ], self . lattice [ tuple (( i + np . roll ( dl , m )) % self . lattice . shape )]] energy += self . interaction [[ self . lattice [ i ], li ], self . lattice [ tuple (( i - np . roll ( dl , m )) % self . lattice . shape )]] return energy","title":"energy_at_site()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.latticebox.sample","text":"update measurements Source code in bubblebox/lattice_models.py def sample ( self ): \"\"\"update measurements\"\"\" self . s_energy = ( self . s_energy * self . samples + self . energy ()) / ( self . samples + 1 ) self . samples += 1 return self . energy","title":"sample()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.polymer","text":"","title":"polymer"},{"location":"lattice_models-reference/#bubblebox.lattice_models.polymer.advance_conformation","text":"Recurrent function for discovering possible conformations. Source code in bubblebox/lattice_models.py def advance_conformation ( self , conformation , points ): \"\"\" Recurrent function for discovering possible conformations. \"\"\" if len ( conformation ) >= len ( self . config ) - 1 : self . conformations . append ( conformation ) else : for i in self . basis : #if not np.all(i == -1*conformation[-1]): if np . sum (( i + conformation [ - 1 ]) ** 2 ) > 0 : new_point = points [ - 1 ] + i if not np . any ( np . sum ( np . abs ( new_point - points ), axis = 1 ) == 0 ): # and np.sum(new_point**2)>0: new_points = points + [ new_point ] new_conformation = conformation + [ i ] self . advance_conformation ( new_conformation , new_points )","title":"advance_conformation()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.polymer.determine_conformations","text":"Explore and determine possible conformations Note The generated conformations contain a lot of redundancy due to symmetries. However, we simply want a set which is compact enough for a somewhat efficient exploration of small polymers. Source code in bubblebox/lattice_models.py def determine_conformations ( self ): \"\"\" Explore and determine possible conformations **Note** The generated conformations contain a lot of redundancy due to symmetries. However, we simply want a set which is compact enough for a somewhat efficient exploration of small polymers. \"\"\" self . advance_conformation ([ np . array ([ 1 , 0 ])], [ np . array ([ 0 , 0 ]), np . array ([ 1 , 0 ])]) # generate transformed conformations transformed_conformations = [] for i in self . conformations : transformed_conformations . append ( i ) transformed_conformations . append ([ np . array ([ j [ 0 ], - j [ 1 ]]) for j in i ]) transformed_conformations . append ([ np . array ([ - j [ 0 ], j [ 1 ]]) for j in i ]) transformed_conformations . append ([ np . array ([ - j [ 0 ], - j [ 1 ]]) for j in i ]) transformed_conformations . append ([ np . array ([ j [ 1 ], j [ 0 ]]) for j in i ]) transformed_conformations . append ([ np . array ([ - j [ 1 ], j [ 0 ]]) for j in i ]) transformed_conformations . append ([ np . array ([ j [ 1 ], - j [ 0 ]]) for j in i ]) transformed_conformations . append ([ np . array ([ - j [ 1 ], - j [ 0 ]]) for j in i ]) self . conformations = transformed_conformations","title":"determine_conformations()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.equilibrate","text":"Equilibrate a lattice system Aaguments n_thresh = number of iterations before we start accumulating energy dn = number of iterations between each sample thresh = assume equilibrated when relative change in energy falls below this threshold Source code in bubblebox/lattice_models.py def equilibrate ( l , n_thresh = 1e5 , dn = 2000 , thresh = 2e-5 ): \"\"\" Equilibrate a lattice system Aaguments n_thresh = number of iterations before we start accumulating energy dn = number of iterations between each sample thresh = assume equilibrated when relative change in energy falls below this threshold \"\"\" # first, move system towards equilibrium # before we start sampling l . evolve ( int ( n_thresh )) # then start sampling the energy n_samples = 0 #number of samples energy_ac = 0 #accumulated energy for i in range ( 200 ): l . evolve ( dn ) ei = l . energy () / l . lattice . size #compute the lattice energy per particle energy_ac_prev = energy_ac #retain previous energy energy_ac = ( energy_ac * n_samples + ei ) / ( n_samples + 1 ) #update accumulated mean energy n_samples += 1 #update number of samples # compute relative change relative_change_in_energy = ( energy_ac - energy_ac_prev ) / energy_ac if np . abs ( relative_change_in_energy ) < thresh : # if relative change in energy is below thresh, # return the equilibrated lattice #print(\"Equilibrated lattice with %i samples, final relative change in energy: %.10e\" % (n_samples, relative_change_in_energy)) return l print ( \"Failed to equilibrate\" ) return l","title":"equilibrate()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.order_2d","text":"for each site on the lattice, measure the number of differing neighbors should be used after equilibration Source code in bubblebox/lattice_models.py def order_2d ( l ): \"\"\" for each site on the lattice, measure the number of differing neighbors should be used after equilibration \"\"\" # compute absolute differences between neighboring sites lnn = 1 - np . abs ( l . lattice - np . roll ( l . lattice , 1 , axis = 0 )) lnn += 1 - np . abs ( l . lattice - np . roll ( l . lattice , - 1 , axis = 0 )) lnn += 1 - np . abs ( l . lattice - np . roll ( l . lattice , 1 , axis = 1 )) lnn += 1 - np . abs ( l . lattice - np . roll ( l . lattice , - 1 , axis = 1 )) # for species A lnn_A = lnn [ l . lattice == 0 ] lnn_A_bins = np . bincount ( lnn_A ) # should be 1 if A perfectly separated # should be 0.5 if perfectly mixed # for species B lnn_B = lnn [ l . lattice == 1 ] lnn_B_bins = np . bincount ( lnn_B ) \"\"\" #summarize results for i in range(len(lnn_A_bins)): print(\"A fraction of %.3f of species A have %i neighbors different than itself \" % (lnn_A_bins[i]/l.number_of_species[0], i)) print(\" \") for i in range(len(lnn_B_bins)): print(\"A fraction of %.3f of species B have %i neighbors different than itself \" % (lnn_B_bins[i]/l.number_of_species[1], i)) \"\"\" # if we only count sites surrounded by at least three molecules # identical to the one occupying the site as being in phase A or B, # and the remaining ones in liquid phase, we can return the following estimates # notice, however, that this is a matter of interpretation n_in_phase_A = lnn_A_bins [: 1 ] . sum () n_in_phase_B = lnn_B_bins [: 1 ] . sum () n_in_mixed_phase = lnn_A_bins [ 1 :] . sum () + lnn_B_bins [ 1 :] . sum () return lnn_A . mean () / 4.0","title":"order_2d()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.order_nd","text":"for each site on the lattice, measure the number of differing neighbors should be used after equilibration Source code in bubblebox/lattice_models.py def order_nd ( l ): \"\"\" for each site on the lattice, measure the number of differing neighbors should be used after equilibration \"\"\" # compute absolute differences between neighboring sites lnn = np . zeros_like ( l . lattice ) for i in range ( len ( l . lattice . shape )): lnn += 1 - np . abs ( l . lattice - np . roll ( l . lattice , 1 , axis = i )) lnn += 1 - np . abs ( l . lattice - np . roll ( l . lattice , - 1 , axis = i )) # for species A lnn_A = lnn #[l.lattice==0] lnn_A_bins = np . bincount ( lnn_A . ravel ()) #print(lnn_A_bins/np.sum(l.lattice==0)) # should be 1 if A perfectly separated # should be 0.5 if perfectly mixed #return lnn_A.mean()/(2*nd) return lnn_A_bins / np . sum ( lnn_A_bins ), np . mean ( lnn )","title":"order_nd()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.remove_rotational_redundance","text":"Remove rotational redundancies from the set of conformations conf Source code in bubblebox/lattice_models.py def remove_rotational_redundance ( conf , remove_reversed = False ): \"\"\" Remove rotational redundancies from the set of conformations conf \"\"\" nonredundant_set = [] #nonredundant conformations to be added here for c in conf : nonredundant = True # if nonredundant, add to nonredundant_set cc = np . array ( c ) # check for redundancies for m in nonredundant_set : mc = np . array ( m ) for j in range ( 4 ): if np . sum (( mc - cc ) ** 2 ) < 1e-10 : nonredundant = False cc = cc . dot ( np . array ([[ 0 , 1 ],[ - 1 , 0 ]])) #rotate polymer 90 degrees if remove_reversed : cc = cc [:: - 1 ] # reverse polymer for j in range ( 4 ): if np . sum (( mc - cc ) ** 2 ) < 1e-10 : nonredundant = False cc = cc . dot ( np . array ([[ 0 , 1 ],[ - 1 , 0 ]])) if nonredundant : nonredundant_set . append ( c ) return nonredundant_set","title":"remove_rotational_redundance()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.show_conformations","text":"Show all possible conformations of polym(er) Source code in bubblebox/lattice_models.py def show_conformations ( polym ): \"\"\" Show all possible conformations of polym(er) \"\"\" n = int ( np . sqrt ( len ( polym . conformations )) + 1 ) sep = 6.5 plt . figure ( figsize = ( 10 , 10 )) c = 0 lp = len ( polym . conformations ) hi = np . array ([ i for i in polym . config ]) == \"H\" pi = np . array ([ i for i in polym . config ]) == \"P\" for i in range ( n ): for j in range ( n ): if c < lp : conf = [ np . array ([ 0 , 0 ])] + polym . conformations [ c ] conf = np . cumsum ( np . array ( conf ), axis = 0 ) conf = conf - np . mean ( conf , axis = 0 )[ None , :] plt . plot ( conf [:, 0 ] + i * sep , conf [:, 1 ] - j * sep , \"-\" , color = ( 0 , 0 , 0 )) plt . plot ( conf [ hi , 0 ] + i * sep , conf [ hi , 1 ] - j * sep , \"o\" , color = ( .8 , .3 , 0 ), markersize = 2 ) plt . plot ( conf [ pi , 0 ] + i * sep , conf [ pi , 1 ] - j * sep , \"o\" , color = ( 0 , .3 , .8 ), markersize = 2 ) c += 1 plt . xlim ( - sep , sep * n + 1 ) plt . ylim ( - sep * n , sep ) plt . axis ( \"off\" ) plt . show ()","title":"show_conformations()"},{"location":"lattice_models-reference/#bubblebox.lattice_models.show_lattice_placement","text":"Show how the lattice l looks when polymer p is placed as defined by positions c Source code in bubblebox/lattice_models.py def show_lattice_placement ( l , p , c ): \"\"\" Show how the lattice l looks when polymer p is placed as defined by positions c \"\"\" if type ( c ) is not list : c = [ c ] n = int ( np . sqrt ( len ( c )) + 1 ) counter = 0 plt . figure ( figsize = ( 2 * l . lattice . shape [ 0 ], 2 * l . lattice . shape [ 1 ])) dx , dy = l . lattice . shape [ 1 ] + 3 , l . lattice . shape [ 0 ] + 3 unique_lattices = [] #list to hold unique lattice configurations for i in range ( n ): for j in range ( n ): if counter < len ( c ): #compute energy of polymer energy_polymer = p . energy () #compute energy of empty cavity energy_cavity = l . energy () pts = np . array ( np . meshgrid ( np . arange ( l . lattice . shape [ 1 ]) + dx * i , np . arange ( l . lattice . shape [ 0 ]) + dy * j )) . reshape ( 2 , - 1 ) . T lat = l . lattice * 1 config = [ l . _edict [ k ] for k in p . config ] lat [ c [ counter ][:, 0 ], c [ counter ][:, 1 ]] = config # compute energy of filled cavity energy_filled = l . energy ( lat ) lat = lat . ravel () lw = lat ==- 1 lh = lat == 0 lp = lat == 1 plt . plot ( pts [ lw , 1 ], pts [ lw , 0 ], \"o\" , markersize = 5 , color = ( .3 , .3 , .8 )) plt . plot ( pts [ lh , 1 ], pts [ lh , 0 ], \"o\" , markersize = 5 , color = ( .9 , .9 , .3 )) plt . plot ( pts [ lp , 1 ], pts [ lp , 0 ], \"o\" , markersize = 5 , color = ( .8 , .4 , .3 )) plt . plot ( pts [ lw , 1 ], pts [ lw , 0 ], \"o\" , markersize = 7 , color = ( 0 , 0 , 0 ), zorder = - 1 ) plt . plot ( pts [ lh , 1 ], pts [ lh , 0 ], \"o\" , markersize = 7 , color = ( 0 , 0 , 0 ), zorder = - 1 ) plt . plot ( pts [ lp , 1 ], pts [ lp , 0 ], \"o\" , markersize = 7 , color = ( 0 , 0 , 0 ), zorder = - 1 ) plt . plot ( c [ counter ][:, 0 ] + dy * j , c [ counter ][:, 1 ] + dx * i , \"-\" , color = ( 0 , 0 , 0 ), zorder = - 1 , linewidth = 2 ) #print(\"Polymer self-energy :\", energy_polymer) #print(\"Energy of empty cavity :\", energy_cavity) #print(\"Energy of filled cavity:\", energy_filled) #print(\"Total energy. :\", energy_filled - energy_cavity - energy_polymer) plt . text ( dy * ( j + .25 ), dx * i - 1 , \"$\\epsilon$ = %i \" % ( energy_filled - energy_cavity - energy_polymer ), ha = \"center\" , va = \"center\" , fontsize = 8 ) counter += 1 plt . axis ( \"off\" ) plt . show ()","title":"show_lattice_placement()"},{"location":"mdbox-reference/","text":"MDBox module animated_system setup_plot ( self ) Initial drawing of the scatter plot. Source code in bubblebox/mdbox.py def setup_plot ( self ): \"\"\"Initial drawing of the scatter plot.\"\"\" x , y = self . system . pos #s = 10 + 2*self.system.masses #c = (1,0,0) #c = np.random.uniform(0,1,(self.system.N_bubbles, 3)) c = colorscheme () Lx = self . system . size [ 0 ] Ly = self . system . size [ 1 ] if Lx > 0 : wx1 = plt . plot ([ - Lx , - Lx ], [ - Ly , Ly ], color = ( 0 , 0 , 0 ), linewidth = 2.0 ) wx2 = plt . plot ([ Lx , Lx ], [ - Ly , Ly ], color = ( 0 , 0 , 0 ), linewidth = 2.0 ) if Ly > 0 : wx3 = plt . plot ([ - Lx , Lx ], [ - Ly , - Ly ], color = ( 0 , 0 , 0 ), linewidth = 2.0 ) wx4 = plt . plot ([ - Lx , Lx ], [ Ly , Ly ], color = ( 0 , 0 , 0 ), linewidth = 2.0 ) if self . scatterplot : s = np . sqrt ( self . system . masses ) * 10 #/self.system.Lx c = c . getcol ( self . system . masses / self . system . masses . max ()) . T self . bubbles = self . ax . scatter ( x , y , c = c , s = s , edgecolor = \"k\" , marker = \"8\" ) #self.bubbles = self.ax.scatter(x, y, s= s, edgecolor=\"k\", marker = \"8\") else : self . bubbles = self . ax . plot ( x , y , \"o\" , color = c . getcol ( .4 ), markersize = 4 )[ 0 ] self . ax . axis ([ - Lx - 1 , Lx + 1 , - Ly - 1 , Ly + 1 ]) L05x = 0.1 L05x = max ( 1 , Lx * 0.05 ) L05y = max ( 1 , Ly * 0.05 ) if self . system . size2 [ 0 ] == 0 : L05x = max ( L05x , 10 * np . abs ( self . system . pos [ 0 ,:]) . max ()) if self . system . size2 [ 1 ] == 0 : L05y = max ( L05y , 10 * np . abs ( self . system . pos [ 1 ,:]) . max ()) plt . xlim ( - Lx - L05x , Lx + L05x ) plt . ylim ( - Ly - L05y , Ly + L05y ) return self . bubbles , box ( mdbox ) Wrapper to mdbox, for backwards compatability. mdbox Simple 2D Lennard-Jones liquid simulation box -- boundary conditions in (x,y) direction: ( x > 0 , _ ) = closed boundary at x and -x ( x = 0 , _ ) = no boundary in x-direction ( x < 0 , _ ) = periodic boundary at x and -x n_bubbles -- number of bubbles (int, default 100) masses -- array containing particle masses (default 1) pos -- array of shape (3, n_bubbles) containing positions vel -- array of scalars with maximum random velocity radius -- relax -- minimize potential energy on initialization using simulated annealing grid -- initial spacing in a grid (default True) Example usage (in a notebook): import hylleraas.bubblebox as bb %matplotlib notebook system = mdbox(n_bubbles = 100, size = (10,10)) #initialize 10 by 10 closed box containing 100 bubbles system.run() #run simulation interactively advance_euler ( self ) Advance one step in time according to the explicit Euler algorithm Source code in bubblebox/mdbox.py def advance_euler ( self ): \"\"\" Advance one step in time according to the explicit Euler algorithm \"\"\" self . vel += self . forces ( self . pos , self . size2 , self . interactions , self . r2_cut , self . force ) * self . dt * self . masses_inv self . pos [ self . active ] += self . vel [ self . active ] * self . dt # impose PBC for i in range ( self . ndim ): if self . size [ i ] < 0 : pos_new [ i , :] = ( pos_new [ i ,:] + self . size [ i ]) % ( self . size2 [ i ]) - self . size [ i ] # impose wall and collision bounary conditions self . vel_ , self . col = collisions ( self . pos , self . vel_ , screen = 10.0 , radius = self . radius , size2 = self . size2 , masses = self . masses , pair_list = self . pair_list ) # Track time self . t += self . dt advance_vverlet ( self ) Advance one step in time according to the Velocity-Verlet algorithm Source code in bubblebox/mdbox.py def advance_vverlet ( self ): \"\"\" Advance one step in time according to the Velocity-Verlet algorithm \"\"\" if self . first_iteration : self . Fn = self . forces ( self . pos , self . size2 , self . interactions , r2_cut = self . r2_cut , force = self . force , pair_list = self . pair_list ) self . first_iteration = False if self . pair_list is not None : if self . iteration % self . pair_list_update_frequency == 0 : self . pair_list = compute_pair_list ( self . pos , self . r2_cut * self . pair_list_buffer , self . size2 ) Fn = self . Fn # field if self . fields : self . Z , dv = gen_field ( self , self . nbins , self . Z ) #self.vel_ = .99*self.vel_ + .01*dv.T Fn += .1 * dv . T self . d_pos = self . vel_ * self . dt + .5 * Fn * self . dt ** 2 * self . masses_inv pos_new = self . pos + self . d_pos forces_new = self . forces ( pos_new , self . size2 , self . interactions , r2_cut = self . r2_cut , force = self . force , pair_list = self . pair_list ) self . vel_ = self . vel_ + .5 * ( forces_new + Fn ) * self . dt * self . masses_inv self . Fn = forces_new # impose PBC for i in range ( self . ndim ): if self . size [ i ] < 0 : pos_new [ i , :] = ( pos_new [ i ,:] + self . size [ i ]) % ( self . size2 [ i ]) - self . size [ i ] # impose wall and collision boundary conditions self . vel_ , self . col = collisions ( pos_new , self . vel_ , screen = 10.0 , radius = self . radius , size2 = self . size2 , masses = self . masses , pair_list = self . pair_list ) #update arrays (in order to retain velocity) self . vel = ( pos_new - self . pos_old ) / ( 2 * self . dt ) self . pos_old [:] = self . pos self . pos [:, self . active ] = pos_new [:, self . active ] # Track time self . t += self . dt self . iteration += 1 compute_energy ( self ) Compute total energy of system Source code in bubblebox/mdbox.py def compute_energy ( self ): \"\"\" Compute total energy of system \"\"\" return self . compute_potential_energy () + self . compute_kinetic_energy () compute_kinetic_energy ( self ) Compute total kinetic energy in system Source code in bubblebox/mdbox.py def compute_kinetic_energy ( self ): \"\"\" Compute total kinetic energy in system \"\"\" # Vektorisert funksjon med hensyn p\u00e5 ytelse return .5 * np . sum ( self . masses * np . sum ( self . vel_ ** 2 , axis = 0 )) compute_potential_energy ( self ) Compute total potential energy in system Source code in bubblebox/mdbox.py def compute_potential_energy ( self ): \"\"\" Compute total potential energy in system \"\"\" #return lj_potential(self.pos, self.interactions, L2x = self.L2x, L2y = self.L2y, r2_cut = self.r2_cut) return lj_potential ( self . pos , self . size2 , interactions = self . interactions , r2_cut = self . r2_cut , force = self . force , pair_list = self . pair_list ) evolve ( self , t = 1.0 ) Let system evolve in time for t seconds Source code in bubblebox/mdbox.py def evolve ( self , t = 1.0 ): \"\"\" Let system evolve in time for t seconds \"\"\" t1 = self . t + t while self . t < t1 : self . advance () kinetic_energies ( self ) Compute kinetic energy of each bubble Source code in bubblebox/mdbox.py def kinetic_energies ( self ): \"\"\" Compute kinetic energy of each bubble \"\"\" # Vektorisert funksjon med hensyn p\u00e5 ytelse return .5 * self . masses * np . sum ( self . vel_ ** 2 , axis = 0 ) visualize_state ( self , axis = False , figsize = None ) Show an image of the current state with positions, velocities (as arrows) and boundaries of the box. Source code in bubblebox/mdbox.py def visualize_state ( self , axis = False , figsize = None ): \"\"\" Show an image of the current state with positions, velocities (as arrows) and boundaries of the box. \"\"\" if figsize is None : figsize = ( 6 , 6 ) if self . L2x != 0 and self . L2y != 0 : figsize = ( 4 , 4 * np . abs ( self . L2y / self . L2x )) plt . rcParams [ \"figure.figsize\" ] = figsize col = colorscheme () plt . figure ( figsize = figsize ) plt . plot ([ - self . Lx , self . Lx , self . Lx , - self . Lx , - self . Lx ],[ - self . Ly , - self . Ly , self . Ly , self . Ly , - self . Ly ], color = ( 0 , 0 , 0 ), linewidth = 2 ) plt . plot ( self . pos [ 0 ], self . pos [ 1 ], 'o' , alpha = .4 , markersize = 8 * 1.8 , color = col . getcol ( .5 )) plt . plot ( self . pos [ 0 ], self . pos [ 1 ], '.' , alpha = 1 , markersize = 10 , color = ( 0 , 0 , 0 )) for i in range ( len ( self . vel [ 0 ])): plt . plot ([ self . pos [ 0 , i ], self . pos [ 0 , i ] + self . vel [ 0 , i ]],[ self . pos [ 1 , i ], self . pos [ 1 , i ] + self . vel [ 1 , i ]], \"-\" , color = ( 0 , 0 , 0 )) th = np . arctan2 ( self . vel [ 1 , i ], self . vel [ 0 , i ]) plt . text ( self . pos [ 0 , i ] + self . vel [ 0 , i ], self . pos [ 1 , i ] + self . vel [ 1 , i ], \"\u25b2\" , rotation = - 90 + 360 * th / ( 2 * np . pi ), ha = \"center\" , va = \"center\" ) #, color = (0,0,0), fontsize = 20, rotation=0, ha = \"center\", va = \"center\") plt . xlim ( - self . Lx - 1 , self . Lx + 1 ) if self . Lx == 0 : plt . xlim ( - 11 , 11 ) plt . ylim ( - self . Ly - 1 , self . Ly + 1 ) if self . Ly == 0 : plt . ylim ( - 11 , 11 ) if not axis : plt . axis ( \"off\" ) plt . show () arrange_in_grid ( pos , Lx , Ly , n_bubbles ) Place n_bubbles in a grid on a Lx by Ly area pos -- position vector Lx, Ly -- dimensions of box n_bubbles -- number of bubbles Source code in bubblebox/mdbox.py def arrange_in_grid ( pos , Lx , Ly , n_bubbles ): \"\"\" Place n_bubbles in a grid on a Lx by Ly area Keyword arguments: pos -- position vector Lx, Ly -- dimensions of box n_bubbles -- number of bubbles \"\"\" a = Ly / Lx nx = int ( np . ceil ( np . sqrt ( n_bubbles / a ))) ny = int ( np . ceil ( a * nx )) count = 0 dn_x = np . linspace ( 0 , 2 * Lx , nx + 1 )[ 1 ] * .5 dn_y = np . linspace ( 0 , 2 * Ly , ny + 1 )[ 1 ] * .5 for i in np . linspace ( - Lx , Lx , nx + 1 )[: - 1 ]: for j in np . linspace ( - Ly , Ly , ny + 1 )[: - 1 ]: pos [:, count ] = [ i + dn_x , j + dn_y ] count += 1 if count >= pos . shape [ 1 ]: break if count >= pos . shape [ 1 ]: break return pos collisions ( coords , vels , screen = 10.0 , radius =- 1.0 , size2 = 0 , masses = None , pair_list = None ) Hard-sphere collision and wall collisions Author: Audun Skau Hansen (a.s.hansen@kjemi.uio.no) coords -- array (2,n_particles) containing positions vels -- array (2,n_particles) containing velocities screen -- screening distance (particles further away not considered) radius -- for positive values, particles are considered hard spheres of equal radius Lx, Ly -- box dimensions, for x: ( x > 0 , _ ) = closed boundary at x and -x ( x = 0 , _ ) = no boundary in x-direction ( x < 0 , _ ) = periodic boundary at x and -x masses -- array containing particle masses (default None) Returns velocities, coordinates Note This functions utilize numba's just-in-time compilation ( nb.jit() ) for optimized performance and readability. Source code in bubblebox/mdbox.py @nb . jit () def collisions ( coords , vels , screen = 10.0 , radius = - 1.0 , size2 = 0 , masses = None , pair_list = None ): \"\"\" Hard-sphere collision and wall collisions Author: Audun Skau Hansen (a.s.hansen@kjemi.uio.no) Keyword arguments: coords -- array (2,n_particles) containing positions vels -- array (2,n_particles) containing velocities screen -- screening distance (particles further away not considered) radius -- for positive values, particles are considered hard spheres of equal radius Lx, Ly -- box dimensions, for x: ( x > 0 , _ ) = closed boundary at x and -x ( x = 0 , _ ) = no boundary in x-direction ( x < 0 , _ ) = periodic boundary at x and -x masses -- array containing particle masses (default None) Returns velocities, coordinates Note ---- This functions utilize numba's just-in-time compilation ( nb.jit() ) for optimized performance and readability. \"\"\" #v = vels*1 r2 = 4 * radius ** 2 R2 = 2 * radius c = 0 size = .5 * size2 size_a = np . abs ( size ) v = vels * 1 for i in range ( coords . shape [ 1 ]): #cix, ciy = coords[0,i],coords[1,i] ci = coords [:, i ] if pair_list is not None : for j in pair_list [ i ]: if j == i : break # distance-based interactions #dx, dy = coords[:,j] - ci #cjx, cjy = coords[0,j], coords[1,j] cj = coords [:, j ] dij = cj - ci #dx = cjx - cix #coords[0,i] #dy = cjy - ciy #coords[1,i] for k in range ( size . shape [ 0 ]): if size [ k ] < 0 : if np . abs ( dij [ k ]) > size_a [ k ]: if dij [ k ] > 0 : dij [ k ] += size2 [ k ] else : dij [ k ] -= size2 [ k ] # Compute distance squared rr = np . sum ( dij ** 2 ) if rr < r2 : #collision detected c += 1 # velocities vij = vels [:, i ] - vels [:, j ] # weight w_dij = np . dot ( vij , dij ) / rr * dij if masses is None : v [:, i ] -= w_dij v [:, j ] += w_dij else : mi = masses [ i ] mj = masses [ j ] m1_m2 = mi + mj wi = 2 * mj / m1_m2 wj = 2 * mi / m1_m2 v [:, i ] -= w_dij * wi v [:, j ] += w_dij * wi # collision with wall for k in range ( size . shape [ 0 ]): if size [ k ] > 0 : if np . abs ( coords [ k , i ]) > size [ k ]: v [ k , i ] *= - 1 c += 1 return v , c coulomb_force ( eps , sig , rr ) eps = Q1 (charge of particle 1) sig = Q2 (charge of particle 2) rr = distance between particles Source code in bubblebox/mdbox.py @nb . jit ( nopython = True ) def coulomb_force ( eps , sig , rr ): \"\"\" eps = Q1 (charge of particle 1) sig = Q2 (charge of particle 2) rr = distance between particles \"\"\" return - eps * sig * rr **- 2 hook_force ( eps , sig , rr ) eps = Q1 (charge of particle 1) sig = Q2 (charge of particle 2) rr = distance between particles Source code in bubblebox/mdbox.py @nb . jit ( nopython = True ) def hook_force ( eps , sig , rr ): \"\"\" eps = Q1 (charge of particle 1) sig = Q2 (charge of particle 2) rr = distance between particles \"\"\" return eps * ( rr - sig ) pos2heatmap ( pos , masses , Lx , Ly , Nz = 11 , col = None ) Create a 2D density array for a set of various bubbles Author: Audun Skau Hansen (a.s.hansen@kjemi.uio.no) pos -- array (2,n_particles) containing positions masses -- array (n_particles) containing masses Lx, Ly -- box dimensions Nz -- number of bins in each dimension Returns an Nz by Nz by 3 array containing colors according to bubble density Source code in bubblebox/mdbox.py def pos2heatmap ( pos , masses , Lx , Ly , Nz = 11 , col = None ): \"\"\" Create a 2D density array for a set of various bubbles Author: Audun Skau Hansen (a.s.hansen@kjemi.uio.no) Keyword arguments: pos -- array (2,n_particles) containing positions masses -- array (n_particles) containing masses Lx, Ly -- box dimensions Nz -- number of bins in each dimension Returns an Nz by Nz by 3 array containing colors according to bubble density \"\"\" #Z = np.zeros((Nz,Nz, 4), dtype = nb.float64) Z = np . zeros (( Nz , Nz , 4 ), dtype = float ) col = colorscheme () masses_norm = masses / masses . max () for i in range ( pos . shape [ 1 ]): ix , iy = int ( Nz * ( pos [ 0 , i ] + Lx ) / ( 2 * Lx ) ), int ( Nz * ( pos [ 1 , i ] + Ly ) / ( 2 * Ly ) ) # Using the mean for N+1 samples here: # mean_{N+1} = (N*mean_N + new_sample)/(N + 1) Z [ ix , iy , : 3 ] = ( Z [ ix , iy , : 3 ] * Z [ ix , iy , 3 ] + col . getcol ( masses_norm [ i ]) ) / ( Z [ ix , iy , 3 ] + 1 ) Z [ ix , iy , 3 ] += 1 return Z [:,:,: 3 ]","title":"mdbox"},{"location":"mdbox-reference/#mdbox-module","text":"","title":"MDBox module"},{"location":"mdbox-reference/#bubblebox.mdbox.animated_system","text":"","title":"animated_system"},{"location":"mdbox-reference/#bubblebox.mdbox.animated_system.setup_plot","text":"Initial drawing of the scatter plot. Source code in bubblebox/mdbox.py def setup_plot ( self ): \"\"\"Initial drawing of the scatter plot.\"\"\" x , y = self . system . pos #s = 10 + 2*self.system.masses #c = (1,0,0) #c = np.random.uniform(0,1,(self.system.N_bubbles, 3)) c = colorscheme () Lx = self . system . size [ 0 ] Ly = self . system . size [ 1 ] if Lx > 0 : wx1 = plt . plot ([ - Lx , - Lx ], [ - Ly , Ly ], color = ( 0 , 0 , 0 ), linewidth = 2.0 ) wx2 = plt . plot ([ Lx , Lx ], [ - Ly , Ly ], color = ( 0 , 0 , 0 ), linewidth = 2.0 ) if Ly > 0 : wx3 = plt . plot ([ - Lx , Lx ], [ - Ly , - Ly ], color = ( 0 , 0 , 0 ), linewidth = 2.0 ) wx4 = plt . plot ([ - Lx , Lx ], [ Ly , Ly ], color = ( 0 , 0 , 0 ), linewidth = 2.0 ) if self . scatterplot : s = np . sqrt ( self . system . masses ) * 10 #/self.system.Lx c = c . getcol ( self . system . masses / self . system . masses . max ()) . T self . bubbles = self . ax . scatter ( x , y , c = c , s = s , edgecolor = \"k\" , marker = \"8\" ) #self.bubbles = self.ax.scatter(x, y, s= s, edgecolor=\"k\", marker = \"8\") else : self . bubbles = self . ax . plot ( x , y , \"o\" , color = c . getcol ( .4 ), markersize = 4 )[ 0 ] self . ax . axis ([ - Lx - 1 , Lx + 1 , - Ly - 1 , Ly + 1 ]) L05x = 0.1 L05x = max ( 1 , Lx * 0.05 ) L05y = max ( 1 , Ly * 0.05 ) if self . system . size2 [ 0 ] == 0 : L05x = max ( L05x , 10 * np . abs ( self . system . pos [ 0 ,:]) . max ()) if self . system . size2 [ 1 ] == 0 : L05y = max ( L05y , 10 * np . abs ( self . system . pos [ 1 ,:]) . max ()) plt . xlim ( - Lx - L05x , Lx + L05x ) plt . ylim ( - Ly - L05y , Ly + L05y ) return self . bubbles ,","title":"setup_plot()"},{"location":"mdbox-reference/#bubblebox.mdbox.box","text":"Wrapper to mdbox, for backwards compatability.","title":"box"},{"location":"mdbox-reference/#bubblebox.mdbox.mdbox","text":"Simple 2D Lennard-Jones liquid simulation box -- boundary conditions in (x,y) direction: ( x > 0 , _ ) = closed boundary at x and -x ( x = 0 , _ ) = no boundary in x-direction ( x < 0 , _ ) = periodic boundary at x and -x n_bubbles -- number of bubbles (int, default 100) masses -- array containing particle masses (default 1) pos -- array of shape (3, n_bubbles) containing positions vel -- array of scalars with maximum random velocity radius -- relax -- minimize potential energy on initialization using simulated annealing grid -- initial spacing in a grid (default True) Example usage (in a notebook): import hylleraas.bubblebox as bb %matplotlib notebook system = mdbox(n_bubbles = 100, size = (10,10)) #initialize 10 by 10 closed box containing 100 bubbles system.run() #run simulation interactively","title":"mdbox"},{"location":"mdbox-reference/#bubblebox.mdbox.mdbox.advance_euler","text":"Advance one step in time according to the explicit Euler algorithm Source code in bubblebox/mdbox.py def advance_euler ( self ): \"\"\" Advance one step in time according to the explicit Euler algorithm \"\"\" self . vel += self . forces ( self . pos , self . size2 , self . interactions , self . r2_cut , self . force ) * self . dt * self . masses_inv self . pos [ self . active ] += self . vel [ self . active ] * self . dt # impose PBC for i in range ( self . ndim ): if self . size [ i ] < 0 : pos_new [ i , :] = ( pos_new [ i ,:] + self . size [ i ]) % ( self . size2 [ i ]) - self . size [ i ] # impose wall and collision bounary conditions self . vel_ , self . col = collisions ( self . pos , self . vel_ , screen = 10.0 , radius = self . radius , size2 = self . size2 , masses = self . masses , pair_list = self . pair_list ) # Track time self . t += self . dt","title":"advance_euler()"},{"location":"mdbox-reference/#bubblebox.mdbox.mdbox.advance_vverlet","text":"Advance one step in time according to the Velocity-Verlet algorithm Source code in bubblebox/mdbox.py def advance_vverlet ( self ): \"\"\" Advance one step in time according to the Velocity-Verlet algorithm \"\"\" if self . first_iteration : self . Fn = self . forces ( self . pos , self . size2 , self . interactions , r2_cut = self . r2_cut , force = self . force , pair_list = self . pair_list ) self . first_iteration = False if self . pair_list is not None : if self . iteration % self . pair_list_update_frequency == 0 : self . pair_list = compute_pair_list ( self . pos , self . r2_cut * self . pair_list_buffer , self . size2 ) Fn = self . Fn # field if self . fields : self . Z , dv = gen_field ( self , self . nbins , self . Z ) #self.vel_ = .99*self.vel_ + .01*dv.T Fn += .1 * dv . T self . d_pos = self . vel_ * self . dt + .5 * Fn * self . dt ** 2 * self . masses_inv pos_new = self . pos + self . d_pos forces_new = self . forces ( pos_new , self . size2 , self . interactions , r2_cut = self . r2_cut , force = self . force , pair_list = self . pair_list ) self . vel_ = self . vel_ + .5 * ( forces_new + Fn ) * self . dt * self . masses_inv self . Fn = forces_new # impose PBC for i in range ( self . ndim ): if self . size [ i ] < 0 : pos_new [ i , :] = ( pos_new [ i ,:] + self . size [ i ]) % ( self . size2 [ i ]) - self . size [ i ] # impose wall and collision boundary conditions self . vel_ , self . col = collisions ( pos_new , self . vel_ , screen = 10.0 , radius = self . radius , size2 = self . size2 , masses = self . masses , pair_list = self . pair_list ) #update arrays (in order to retain velocity) self . vel = ( pos_new - self . pos_old ) / ( 2 * self . dt ) self . pos_old [:] = self . pos self . pos [:, self . active ] = pos_new [:, self . active ] # Track time self . t += self . dt self . iteration += 1","title":"advance_vverlet()"},{"location":"mdbox-reference/#bubblebox.mdbox.mdbox.compute_energy","text":"Compute total energy of system Source code in bubblebox/mdbox.py def compute_energy ( self ): \"\"\" Compute total energy of system \"\"\" return self . compute_potential_energy () + self . compute_kinetic_energy ()","title":"compute_energy()"},{"location":"mdbox-reference/#bubblebox.mdbox.mdbox.compute_kinetic_energy","text":"Compute total kinetic energy in system Source code in bubblebox/mdbox.py def compute_kinetic_energy ( self ): \"\"\" Compute total kinetic energy in system \"\"\" # Vektorisert funksjon med hensyn p\u00e5 ytelse return .5 * np . sum ( self . masses * np . sum ( self . vel_ ** 2 , axis = 0 ))","title":"compute_kinetic_energy()"},{"location":"mdbox-reference/#bubblebox.mdbox.mdbox.compute_potential_energy","text":"Compute total potential energy in system Source code in bubblebox/mdbox.py def compute_potential_energy ( self ): \"\"\" Compute total potential energy in system \"\"\" #return lj_potential(self.pos, self.interactions, L2x = self.L2x, L2y = self.L2y, r2_cut = self.r2_cut) return lj_potential ( self . pos , self . size2 , interactions = self . interactions , r2_cut = self . r2_cut , force = self . force , pair_list = self . pair_list )","title":"compute_potential_energy()"},{"location":"mdbox-reference/#bubblebox.mdbox.mdbox.evolve","text":"Let system evolve in time for t seconds Source code in bubblebox/mdbox.py def evolve ( self , t = 1.0 ): \"\"\" Let system evolve in time for t seconds \"\"\" t1 = self . t + t while self . t < t1 : self . advance ()","title":"evolve()"},{"location":"mdbox-reference/#bubblebox.mdbox.mdbox.kinetic_energies","text":"Compute kinetic energy of each bubble Source code in bubblebox/mdbox.py def kinetic_energies ( self ): \"\"\" Compute kinetic energy of each bubble \"\"\" # Vektorisert funksjon med hensyn p\u00e5 ytelse return .5 * self . masses * np . sum ( self . vel_ ** 2 , axis = 0 )","title":"kinetic_energies()"},{"location":"mdbox-reference/#bubblebox.mdbox.mdbox.visualize_state","text":"Show an image of the current state with positions, velocities (as arrows) and boundaries of the box. Source code in bubblebox/mdbox.py def visualize_state ( self , axis = False , figsize = None ): \"\"\" Show an image of the current state with positions, velocities (as arrows) and boundaries of the box. \"\"\" if figsize is None : figsize = ( 6 , 6 ) if self . L2x != 0 and self . L2y != 0 : figsize = ( 4 , 4 * np . abs ( self . L2y / self . L2x )) plt . rcParams [ \"figure.figsize\" ] = figsize col = colorscheme () plt . figure ( figsize = figsize ) plt . plot ([ - self . Lx , self . Lx , self . Lx , - self . Lx , - self . Lx ],[ - self . Ly , - self . Ly , self . Ly , self . Ly , - self . Ly ], color = ( 0 , 0 , 0 ), linewidth = 2 ) plt . plot ( self . pos [ 0 ], self . pos [ 1 ], 'o' , alpha = .4 , markersize = 8 * 1.8 , color = col . getcol ( .5 )) plt . plot ( self . pos [ 0 ], self . pos [ 1 ], '.' , alpha = 1 , markersize = 10 , color = ( 0 , 0 , 0 )) for i in range ( len ( self . vel [ 0 ])): plt . plot ([ self . pos [ 0 , i ], self . pos [ 0 , i ] + self . vel [ 0 , i ]],[ self . pos [ 1 , i ], self . pos [ 1 , i ] + self . vel [ 1 , i ]], \"-\" , color = ( 0 , 0 , 0 )) th = np . arctan2 ( self . vel [ 1 , i ], self . vel [ 0 , i ]) plt . text ( self . pos [ 0 , i ] + self . vel [ 0 , i ], self . pos [ 1 , i ] + self . vel [ 1 , i ], \"\u25b2\" , rotation = - 90 + 360 * th / ( 2 * np . pi ), ha = \"center\" , va = \"center\" ) #, color = (0,0,0), fontsize = 20, rotation=0, ha = \"center\", va = \"center\") plt . xlim ( - self . Lx - 1 , self . Lx + 1 ) if self . Lx == 0 : plt . xlim ( - 11 , 11 ) plt . ylim ( - self . Ly - 1 , self . Ly + 1 ) if self . Ly == 0 : plt . ylim ( - 11 , 11 ) if not axis : plt . axis ( \"off\" ) plt . show ()","title":"visualize_state()"},{"location":"mdbox-reference/#bubblebox.mdbox.arrange_in_grid","text":"Place n_bubbles in a grid on a Lx by Ly area pos -- position vector Lx, Ly -- dimensions of box n_bubbles -- number of bubbles Source code in bubblebox/mdbox.py def arrange_in_grid ( pos , Lx , Ly , n_bubbles ): \"\"\" Place n_bubbles in a grid on a Lx by Ly area Keyword arguments: pos -- position vector Lx, Ly -- dimensions of box n_bubbles -- number of bubbles \"\"\" a = Ly / Lx nx = int ( np . ceil ( np . sqrt ( n_bubbles / a ))) ny = int ( np . ceil ( a * nx )) count = 0 dn_x = np . linspace ( 0 , 2 * Lx , nx + 1 )[ 1 ] * .5 dn_y = np . linspace ( 0 , 2 * Ly , ny + 1 )[ 1 ] * .5 for i in np . linspace ( - Lx , Lx , nx + 1 )[: - 1 ]: for j in np . linspace ( - Ly , Ly , ny + 1 )[: - 1 ]: pos [:, count ] = [ i + dn_x , j + dn_y ] count += 1 if count >= pos . shape [ 1 ]: break if count >= pos . shape [ 1 ]: break return pos","title":"arrange_in_grid()"},{"location":"mdbox-reference/#bubblebox.mdbox.collisions","text":"Hard-sphere collision and wall collisions Author: Audun Skau Hansen (a.s.hansen@kjemi.uio.no) coords -- array (2,n_particles) containing positions vels -- array (2,n_particles) containing velocities screen -- screening distance (particles further away not considered) radius -- for positive values, particles are considered hard spheres of equal radius Lx, Ly -- box dimensions, for x: ( x > 0 , _ ) = closed boundary at x and -x ( x = 0 , _ ) = no boundary in x-direction ( x < 0 , _ ) = periodic boundary at x and -x masses -- array containing particle masses (default None) Returns velocities, coordinates","title":"collisions()"},{"location":"mdbox-reference/#bubblebox.mdbox.collisions--note","text":"This functions utilize numba's just-in-time compilation ( nb.jit() ) for optimized performance and readability. Source code in bubblebox/mdbox.py @nb . jit () def collisions ( coords , vels , screen = 10.0 , radius = - 1.0 , size2 = 0 , masses = None , pair_list = None ): \"\"\" Hard-sphere collision and wall collisions Author: Audun Skau Hansen (a.s.hansen@kjemi.uio.no) Keyword arguments: coords -- array (2,n_particles) containing positions vels -- array (2,n_particles) containing velocities screen -- screening distance (particles further away not considered) radius -- for positive values, particles are considered hard spheres of equal radius Lx, Ly -- box dimensions, for x: ( x > 0 , _ ) = closed boundary at x and -x ( x = 0 , _ ) = no boundary in x-direction ( x < 0 , _ ) = periodic boundary at x and -x masses -- array containing particle masses (default None) Returns velocities, coordinates Note ---- This functions utilize numba's just-in-time compilation ( nb.jit() ) for optimized performance and readability. \"\"\" #v = vels*1 r2 = 4 * radius ** 2 R2 = 2 * radius c = 0 size = .5 * size2 size_a = np . abs ( size ) v = vels * 1 for i in range ( coords . shape [ 1 ]): #cix, ciy = coords[0,i],coords[1,i] ci = coords [:, i ] if pair_list is not None : for j in pair_list [ i ]: if j == i : break # distance-based interactions #dx, dy = coords[:,j] - ci #cjx, cjy = coords[0,j], coords[1,j] cj = coords [:, j ] dij = cj - ci #dx = cjx - cix #coords[0,i] #dy = cjy - ciy #coords[1,i] for k in range ( size . shape [ 0 ]): if size [ k ] < 0 : if np . abs ( dij [ k ]) > size_a [ k ]: if dij [ k ] > 0 : dij [ k ] += size2 [ k ] else : dij [ k ] -= size2 [ k ] # Compute distance squared rr = np . sum ( dij ** 2 ) if rr < r2 : #collision detected c += 1 # velocities vij = vels [:, i ] - vels [:, j ] # weight w_dij = np . dot ( vij , dij ) / rr * dij if masses is None : v [:, i ] -= w_dij v [:, j ] += w_dij else : mi = masses [ i ] mj = masses [ j ] m1_m2 = mi + mj wi = 2 * mj / m1_m2 wj = 2 * mi / m1_m2 v [:, i ] -= w_dij * wi v [:, j ] += w_dij * wi # collision with wall for k in range ( size . shape [ 0 ]): if size [ k ] > 0 : if np . abs ( coords [ k , i ]) > size [ k ]: v [ k , i ] *= - 1 c += 1 return v , c","title":"Note"},{"location":"mdbox-reference/#bubblebox.mdbox.coulomb_force","text":"eps = Q1 (charge of particle 1) sig = Q2 (charge of particle 2) rr = distance between particles Source code in bubblebox/mdbox.py @nb . jit ( nopython = True ) def coulomb_force ( eps , sig , rr ): \"\"\" eps = Q1 (charge of particle 1) sig = Q2 (charge of particle 2) rr = distance between particles \"\"\" return - eps * sig * rr **- 2","title":"coulomb_force()"},{"location":"mdbox-reference/#bubblebox.mdbox.hook_force","text":"eps = Q1 (charge of particle 1) sig = Q2 (charge of particle 2) rr = distance between particles Source code in bubblebox/mdbox.py @nb . jit ( nopython = True ) def hook_force ( eps , sig , rr ): \"\"\" eps = Q1 (charge of particle 1) sig = Q2 (charge of particle 2) rr = distance between particles \"\"\" return eps * ( rr - sig )","title":"hook_force()"},{"location":"mdbox-reference/#bubblebox.mdbox.pos2heatmap","text":"Create a 2D density array for a set of various bubbles Author: Audun Skau Hansen (a.s.hansen@kjemi.uio.no) pos -- array (2,n_particles) containing positions masses -- array (n_particles) containing masses Lx, Ly -- box dimensions Nz -- number of bins in each dimension Returns an Nz by Nz by 3 array containing colors according to bubble density Source code in bubblebox/mdbox.py def pos2heatmap ( pos , masses , Lx , Ly , Nz = 11 , col = None ): \"\"\" Create a 2D density array for a set of various bubbles Author: Audun Skau Hansen (a.s.hansen@kjemi.uio.no) Keyword arguments: pos -- array (2,n_particles) containing positions masses -- array (n_particles) containing masses Lx, Ly -- box dimensions Nz -- number of bins in each dimension Returns an Nz by Nz by 3 array containing colors according to bubble density \"\"\" #Z = np.zeros((Nz,Nz, 4), dtype = nb.float64) Z = np . zeros (( Nz , Nz , 4 ), dtype = float ) col = colorscheme () masses_norm = masses / masses . max () for i in range ( pos . shape [ 1 ]): ix , iy = int ( Nz * ( pos [ 0 , i ] + Lx ) / ( 2 * Lx ) ), int ( Nz * ( pos [ 1 , i ] + Ly ) / ( 2 * Ly ) ) # Using the mean for N+1 samples here: # mean_{N+1} = (N*mean_N + new_sample)/(N + 1) Z [ ix , iy , : 3 ] = ( Z [ ix , iy , : 3 ] * Z [ ix , iy , 3 ] + col . getcol ( masses_norm [ i ]) ) / ( Z [ ix , iy , 3 ] + 1 ) Z [ ix , iy , 3 ] += 1 return Z [:,:,: 3 ]","title":"pos2heatmap()"}]}